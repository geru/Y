<?php

// include field management functionality
require_once 'y.fieldmgt.inc';

// include YAML callback functions
require_once 'y.yamlcallables.inc';

/**
 * Implements hook_hook_info().
 */
function y_hook_info() {
  return array( 'y' => array( 'group' => 'y') );
}

/** Array flattening / unflattening ************************/

/**
 * Flatten an array to one-dimensional with keys imploded with delimiter
 * @param array $array   // array to be flattened
 * @param string $prefix // current prefix for key
 * @param string $delim  // glue delimiter for key
 * @param null $ret      // array to put result in
 * @return array|null    // returns current level of array
 */
function y__array_flatten( array $array, $prefix='', $delim = ':', &$ret=NULL ) {
  if( $ret === NULL ) {
    $ret = array();
  }
  foreach( $array as $key => $value ){
    if( is_array($value) && $value ) {
      y__array_flatten( $value, $prefix . $key . $delim, $delim, $ret );
    } else {
      $ret[ $prefix . $key ] = $value;
    }
  }
  return( $ret );
}

/**
 * Unflatten 1D array into multi-dimensional
 * @param $prefix
 * @param $array / one-dimensional
 * @param string $glue
 */
function y__array_unflatten( array $array, $delim = ':') {
  $ret = array();
  foreach($array as $key => $value) {
    $workret = &$ret;
    $deepkeys = explode( $delim, $key );
    $finalkey = array_shift($deepkeys);
    foreach( $deepkeys as $curkey ) {
      if( !isset($workret[$finalkey] ) ) {
        $workret[$finalkey] = array();
      }
      $workret = &$workret[$finalkey];
      $finalkey = $curkey;
    }
    $workret[$finalkey] = $value;
  }
  return $ret;
}

/** Main YAML retrieval ************************************/

/**
 * Fetch all of the information defined by the owning module according to the protocol
 * This is the meat of it all
 * @param null $owner
 * @param $protocol
 * @return array of protocol information keyed by module implementing protocol
 *
 * todo: add callback indexing and caching
 */
function y__info( $protocol, $owner = NULL, $format='tree' ) {
  $modulesimplement = &drupal_static(__FUNCTION__ . ':modulesimplement', NULL);
  // An array keyed by protocol of the modules implementing the protocol
  // Eg. $modulesimplement['hook'] = array( 'bc', 'bcfeeds' )

  $protocolsimplemented = &drupal_static(__FUNCTION__ . ':protocolsimplemented', array());
  // An array keyed by modulename of the protocols implemented by the module
  // Eg. $protocolsimplemented['bc'] = array( 'hook', 'entity', 'bctype' );

  $yinfo = &drupal_static(__FUNCTION__, array());
  // A multi-dim array of the modules implementing protocols keyed by protocol and module
  // Eg. $yinfo[$protocol][$module] = array(... )

  // Initialize self
  if( $modulesimplement === NULL ) { // todo: getting burned by this logic if hook not declared by hook_y()
    $modulesimplement = array();
    // any time a new protocol is requested, something has changed, clear information and reload
    //$modulesimplement = array();
    // $modulesimplement[$protocol] = array();
    // $protocolsimplemented = array();
  }
  if( !isset($modulesimplement[$protocol]) || ($owner && !isset($protocolsimplemented[$owner])) ) {
    $modules = module_implements('y');
    foreach ($modules as $module) {
      $protocolsimplemented[$module] = module_invoke($module, 'y');
      foreach ($protocolsimplemented[$module] as $p) {
        if (!isset($modulesimplement[$p])) {
          $modulesimplement[$p] = array();
        }
        $modulesimplement[$p][] = $module;
        if (!isset($yinfo[$p])) {
          $yinfo[$p] = array();
        }
      }
    }
  }
  $modules = $owner
    ? array($owner)
    : $modulesimplement[$protocol] ?? array();
  if( !$modules ) {
    return( array() );
  }
  //    $warning = t( 'Undeclared protocol !protocol requested. Owner: !owner.', array('!protocol' => $protocol, '!owner' => $owner));
  //    watchdog('Y', $warning);
  //    drupal_set_message('Y: ' . $warning, 'error');
  $backdoor = & drupal_static('y__backdoor_for_uninstall');
  if( $owner && !$backdoor ) {
    if (!isset($protocolsimplemented[$owner])) { // This happens for hook_schema... trouble
        return array();
    } else {
      if (!in_array($protocol, $protocolsimplemented[$owner])) {
        $warning = t('Protocol !protocol requested  of module !module that does not support it.', array(
          '!protocol' => $protocol,
          '!module' => $owner
        ));
        watchdog('Y', $warning);
        drupal_set_message('Y: ' . $warning, 'error');
      }
    }
  }
  if( isset($warning) ) {
    return array();
  }

  if( $owner && isset($yinfo[$protocol][$owner]) ) {
    return $format ? $yinfo[$protocol][$owner][$format] : $yinfo[$protocol][$owner];
  }

  foreach( $modules as $module ) {
    $callbacks = array(
      '!t' => 'y__yaml_callback_t',
      '!module' => 'y__yaml_callback_plugin_module',
      '!path' => 'y__yaml_callback_plugin_path',
      '!relativepath' => 'y__yaml_callback_plugin_relativepath',
      '!name' => 'y__yaml_callback_plugin_name',
      '!local' => 'y__yaml_callback_plugin_local',
      '!call' => 'y__yaml_callback_call_user_func_array',
      '!var' => 'y__yaml_callback_var',
      '!setplugin' => 'y__yaml_callback_plugin_set',
      '!menucallback' => 'y__yaml_callback_plugin_menucallback',
      '!callback' => 'y__yaml_callback_plugin_callback',
      '!protocol' => 'y__yaml_callback_plugin_protocol',
      '!eval' => 'y__yaml_callback_eval',
    );
    // get config path for the module
    if( !isset($yinfo['_config'][$module] ) ) {
      $modulepath = ($backdoor ?? drupal_get_path('module', $module)) . '/';
      foreach( array($modulepath => $module . '.yaml', $modulepath . 'config/' => '_config.yaml') as $path => $filename ) {
        if (file_exists($path . $filename) ) {
          $filebase = pathinfo($filename, PATHINFO_FILENAME);
          _y__stack_push( 'y__yaml_plugin_values',
            array(
              'path' => $path,
              'module' => $module,
              'protocol' => '_config',
              'file' => $filebase . 'inc',
              'uri' => $path . $filebase . '.inc',
              'name' => $filebase, // 'bctype'
              'yaml uri' => $path . $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
              'filename' => $filename // 'bctype.yaml'
            ) );
          if((($_config = yaml_parse($path . $filename, 0, $n, $callbacks)) !== FALSE)) {
            if (!isset($_config['path'])) {
              $_config['path'] = $path;
              $_config['filename'] = $filename;
            }
            _y__stack_pop('y__yaml_plugin_values');
            break;
          }
          _y__stack_pop('y__yaml_plugin_values');
        }
      }
      $yinfo['_config'][$module] = $_config ?? array('path' => $modulepath . 'config/');
    }
    if (!isset($yinfo[$protocol][$module]) ) {
      $conf = $yinfo['_config'][$module];
      $initarray = isset($yinfo['_config'][$module][$protocol]) ? $yinfo['_config'][$module][$protocol] : array();
      $filename = $conf['path'] . $protocol . '.yaml';
      // todo: find callbacks yaml and callbacks PHP if they will be found
      if( file_exists($filename) ) {
        _y__stack_push('y__yaml_plugin_values',
          array(
            'path' => $conf['path'],
            'module' => $module,
            'protocol' => $protocol,
            'file' => $protocol . '.inc',
            'uri' => $conf['path'] . $protocol . '.inc',
            'name' => $protocol, // 'bctype'
            'yaml uri' => $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $protocol . '.yaml' // 'bctype.yaml'
          ) );
        // $protocolinfo = (($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ? $info : $initarray);
        if( ($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ) {
          $protocolinfo = $info;
        } else {
          $protocolinfo = $initarray;
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $filename, 'warning');
        }
        _y__stack_pop('y__yaml_plugin_values');
      } else {
        $protocolinfo = $initarray; 
      }
      $yinfo[$protocol][$module] = $protocolinfo
        ? array( 'tree' => $protocolinfo,
                 'flat' => y__array_flatten($protocolinfo) )
        : array( 'tree' => array(), 'flat' => array() );

      foreach (file_scan_directory($conf['path'] . $protocol, '|.*\.y.?ml|') as $file) {
        if( $path = dirname($file->uri) ) { $path .= '/'; }
        _y__stack_push('y__yaml_plugin_values',
          array(
            'path' => $path,
            'module' => $module,
            'protocol' => $protocol,
            'file' => $file->name . '.inc',
            'uri' => $path . $file->name . '.inc',
            'name' => $file->name, // 'bctype'
            'yaml uri' => $file->uri, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $file->filename // 'bctype.yaml'
         ) );
        if (($info = yaml_parse_file($file->uri, 0, $n, $callbacks)) !== FALSE) {
          $yinfo[$protocol][$module] = array(
            'tree' => array_merge($yinfo[$protocol][$module]['tree'], $info ),
            'flat' => array_merge($yinfo[$protocol][$module]['flat'], y__array_flatten($info) ) );
        } else {
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $file->uri, 'warning');
        }
        _y__stack_pop('y__yaml_plugin_values');
      }
    }
  }
  if( $owner ) {
    return isset($yinfo[$protocol][$owner][$format]) ? $yinfo[$protocol][$owner][$format] : array();
  } else {
    $ret = array();
    foreach( $yinfo[$protocol] as $name => $info ) {
      $ret = array_merge( $ret, $info[$format] );
    }
    return $ret;
  }
}

/** YAML build functions ***********************************/

/**
 * Build config array from patterns
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $patterns the patterns to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_pattern( $protocol, $module, $patterns, &$info=NULL ) {
  $yinfo = y__info( $protocol, $module, 'flat' );
  $buildflat = array();
  foreach( $patterns as $pattern => $filter ) {
    if( !is_array($filter) ) { // this is a simple pattern
      $pattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
      $mainpattern = $pattern;
      $mainreplacement = $filter;
    } else { // this is pure regex and all patterns and replacements are regex-perfect
      $mainpattern = array_keys($filter);
      $mainreplacement = array_values($filter);
    }
    $matchingkeys = preg_grep($pattern, array_keys($yinfo));
    $replacementkeys = preg_replace( $mainpattern, $mainreplacement, $matchingkeys );
    foreach( $matchingkeys as $index => $key ) {
      $buildflat[$replacementkeys[$index]] = $yinfo[$key];
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $info === NULL ) {
    return $buildflat;
  }
  $info = array_merge($info, $buildflat);
  return $info;
}

/**
 * Build branch array to root from pattern
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $pattern the pattern to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_branch( $module, $protocol, $pattern, &$info=NULL ) {
  $branchsearched = array();
  $yinfo = y__info( $protocol, $module, 'flat' );
  $buildflat = array();
  $childpattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
  $matchingkeys = preg_grep($childpattern, array_keys($yinfo));
  foreach( $matchingkeys as $key ) {
    $buildflat[$key] = $yinfo[$key];
    if( ($colpos = strrpos($key, ':')) !== FALSE ) {
      $key = substr($key, 0, $colpos);
      if( empty($branchsearched[$key]) ) {
        $branchsearched[$key] = TRUE;
        while( ($colpos = strrpos($key, ':')) !== FALSE ) {
          $key = substr($key, 0, $colpos);
          $parentpattern = '|^' . $key . ':([^:]*?)$|';
          $parentkeys = preg_grep($parentpattern, array_keys($yinfo));
          foreach ($parentkeys as $parentkey) {
            if (!isset($buildflat[$parentkey])) {
              $buildflat[$parentkey] = $yinfo[$parentkey];
            }
            else {
              $key = '';
              break;
            }
          }
        }
      }
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $info === NULL ) {
    return $buildflat;
  }
  $info = array_merge($info, $buildflat);
  return $info;
}

/** Packaged YAML protocol controllers *********************/

/**
 * Iterate through a set of protocols and get an array of all the api information in them.
 * @param array $protocols
 * @param $module
 * @param $api
 * @return array
 */
function y__protocol_get_all( $protocols, $api, $module, $squishiness=0 ) {
  if( !is_array($protocols) ) {
    $protocols = array($protocols);
  }
  $ret = array();
  foreach( $protocols as $protocol ) {
    $yinfo = y__protocol( $protocol, $api, $module );
    $ret += $yinfo;
  }
  if( $squishiness ) {
    if( $squishiness > 0 ) {
      while( $squishiness-- ) {
        foreach( $ret as $key => $value) {
          if( is_array($value) ) {
            unset( $ret[$key]);
            $ret += $value;
          }
        }
      }
    }
  }
  return $ret;
}

/**
 * @param string $path path to module, provides backdoor when uninstalling
 */
function y__modulepath_set_override( string $path ) {
  $modulepath = & drupal_static('y__backdoor_for_uninstall');
  $modulepath = $path;
}

/**
 * Main y controller router
 * @param $protocol
 * @param ... more parameters
 * @return array of protocol information supplied by controller
 */
function y__protocol(string $protocol, string $api, $module=NULL, array &$info=NULL) {
  static $addonprotocolsfetched = FALSE;
  static $protocoldef = array(
    'instance' => array(),
    'field' =>    array(),
    'protocol' => array(),
    'entity' => array(
      'schema' => array(
        'pattern' => array(
          "*:schema:" => '$1:$2',
          "*:description" => '$1:description',
          "*:properties:*:schema:" => '$1:fields:$2:$3' ) ),
      'property info alter' => array(
        'pattern' => array(
          "*:properties:*:info:" => '$1:properties:$2:$3' ) ),
    ),
  );
  if( !isset($info) ) {
    $info = array();
  }
  if( !isset($protocoldef[$protocol]) ) {
    if( !$addonprotocolsfetched ) {
      $protocoldef += y__info('protocol');
      $addonprotocolsfetched = TRUE;
    }
    if( !isset($protocoldef[$protocol]) ) { // if still not set after retrieving protocols, set an empty stub
      $protocoldef[$protocol] = array();
    }
  }
  $protocol_instructions = $protocoldef[$protocol][$api] ?? ($protocoldef[$protocol]['default'] ?? array( 'array' => '+' ));
  foreach( $protocol_instructions as $buildtype => $patterns ) {
    switch( $buildtype ) {
      case 'pattern':
        y__build_pattern($protocol, $module, $patterns, $info);
        break;
      case 'array':
      default:
        $yinfo = $yinfo ?? y__info($protocol, $module);
        foreach ($yinfo as $key => $apiinfo) {
          if( isset($apiinfo[$api]) ) {
            $info[$key] = $info[$key] ?? array();
            switch ($patterns) {
              case '+':
                $info[$key] += $apiinfo[$api];
                break;
              case 'merge':
                $info[$key] = array_merge($info[$key], $apiinfo[$api]);
                break;
              default:
                if (function_exists($patterns)) {
                  $info[$key] = call_user_func($patterns, $info[$key], $apiinfo[$api]);
                }
                break;
            }
          }
        }
        break;
    }
  }
  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function y_entity_property_info_alter(&$info) {
  y__protocol('entity', 'property info alter', NULL, $info );
}

/** Function does nothing and can be passed as default to y__plugin so result is guaranteed to be callable */
function _y__donothing() {
  return;
}

/**
 * Plugin functionality
 * if '_y__donothing' passed as default, then it always returns a valid callable function name
 * callback is of form:
 *   callbackname: name_of_function OR
 *   callbackname:
 *     function: name_of_function
 *     uri: file_containing_function_definition
 * @param $info an array of configuration information (eg. all the form information associated with an entity) 
 * @param $type a selector into that array (eg. the bundle name using a form) (use NULL if $info has the callbackname directly)
 * @param $callbackname the callback name (eg. form validation)
 * @param string $default (eg. the name of a default function to be returned if nothing else pans out)
 * @return string the name of a callable function or the default (which may be a callable function name)
 */
function y__plugin( array $info, string $type, string $callbackname, $default='' ): string {
  $callback = ($type === NULL)
    ? $info[$callbackname] ?? $default
    : $info[$type][$callbackname] ?? $default;
  if( $callback ) {
    if( is_array( $callback ) ) {
      if (!empty($callback['uri']) && file_exists($callback['uri'])) {
        require_once $callback['uri'];
      }
      $callbackname = $callback['function'] ?? $default;
    } else {
      $callbackname = $callback;
    }
  } else {
    $callbackname = $default;
  }
  $ret = function_exists($callbackname) ? $callbackname : $default;
  return $ret;
}

/**
 * Implements hook_init() and instantiates all Drupal hooks defined with the "hook" protocol

function _y_init() {
  // Instantiate YAML-defined local hooks
  if ( ($hookfunctiondefs = cache_get(__FUNCTION__)) === FALSE) {
    $hookfunctiondefs = new stdClass();
    $hookfunctiondefs->data = '';

    if ($hookdef = y__protocol_hook(NULL, 'local hooks')) {
      foreach ($hookdef as $hookmodule => $hooks) {
        foreach ($hooks as $hookname => $hookinfo) {
          $hookfunctiondefs->data .= "\nfunction " . $hookmodule . '_' . $hookname . '(){return ' . var_export($hookinfo, TRUE) . ';}';
        }
      }
      cache_set(__FUNCTION__, $hookfunctiondefs->data);
    }
  }
  if (!empty($hookfunctiondefs->data)) {
    try {
      eval($hookfunctiondefs->data);
    }
    catch (ParseError $e) { // got to clear the error-full statement to be able to move forward.
      cache_set( __FUNCTION__, FALSE );
      _drupal_exception_handler( $e );
    }
  }
}
*/

/**
 * Query / display functionality
 */
function y__display_array($table) {
  $args = func_get_args();
  $output = array();
  foreach( $args as $key => $value ) {
    $output[] = array(
      '#title' => $key,
      '#type' => 'textfield',
      '#value' => (string) $value,
    );
  }
  return $output;
}

/**
 * Recursively substitute special patterns in array
 * @param $var
 * @param $substarray
 */
function _y__var_substitute( & $var, $substarray ) {
  if( !is_array($var) ) {
    $var = strtr( $var, $substarray );
  } else {
    foreach( $var as & $value ) {
      _y__var_substitute( $value, $substarray );
    }
  }
  return $var;
}

/*
function _y__display_tokenreplace($variable, $tokens) {
  if( is_array($variable) ) {
    foreach ($variable as $key => & $value) {
      $value = _y__display_tokenreplace($value, $tokens);
    }
  } else {
    $variable = strtr( $variable, $tokens );
  }
  return $variable;
}
*/

/**
 * Display a query result set as a table using the given render rules
 * @param $resultset   // stuff to display, array of arrays or objects
 * @param null $render // settings to initialize output
 * @return array|null  // table render array
 */
function y__display_table( $resultset,  $render=NULL ) {
  if( !$render ) {
    $render = array(
                'querytable' => array(
                  '#empty' => t('No results'), ) );
  }
  $format_def = reset($render);
  $name = key($render);
  $header = $format_def['#header'] ?? array();
  $row_def = $format_def['#rows'] ?? array();
  $tokens = array();
  $rows = array();

  foreach( $resultset as $result ) {
    $result = (array)$result;
    if( !$tokens ) {
      $tokens = array_keys($result);
      foreach( $tokens as &$token ) {
        $token = '[' . $token . ']';
      }
    }
    if (!$header) {
      $header = array_combine(array_keys($result), array_keys($result));
    }
    if( !$row_def ) {
      $rows[] = $result;
    } else {
      $rows[] = _y__var_substitute($row_def, array_combine($tokens,array_values($result)));
    }
  }
  $render[$name] = array_merge( $render[$name],
    array(
      '#theme' => 'table',
      '#header' => $header,
      '#rows' => $rows,
    )
  );
  return $render;
}

/**
 * transform a token of a particular type into its values
 * @param $token of form
 *   global: globalvarname: globalvarproperty OR
 *           globalvarname
 * @return token value if successful, null if unsuccessful
 */
function _y__token_data( array $token ) {
  $value = reset( $token );
  $method = key($token);
  switch ( $method ) {
    case 'global':
      if (is_array($value)) {
        $varprop = reset($value);
        $varname = key($value);
        global $$varname;
        return $$varname->$varprop;
      }
      else {
        global $$value;
        return $$value;
      }
      break;
    case 'session':
      return $_SESSION[$value];
      break;
    case 'callback':
      if( is_array($value) ) {
        $name = key($value);
        if( is_integer($name) ) {
          $function = reset($value);
          $args = array();
        } else {
          $function = $name;
          if( !($args = reset($value)) ) {
            $args = array();
          }
        }
      } else {
        $function = $value;
        $args = array();
      }

      return call_user_func_array( $function, $args );
  }

  return NULL;
}

// Helper function to show a query string
function _y__query_get_string(SelectQueryInterface $query) {
  $string = (string) $query;
  $arguments = $query->arguments();

  if (!empty($arguments) && is_array($arguments)) {
    foreach ($arguments as $placeholder => &$value) {
      if (is_string($value)) {
        $value = "'$value'";
      }
    }

    $string = strtr($string, $arguments);
  }

  return $string;
}

/**
 * Build a query from a query definition array
 * @param $config
 * @return array
 */
function y__query_build( $config ) {
  if( empty($config['base table'])) {
    return array();
  }

  $config += array( 'arguments' => array(), 'build' => array() );
  // Get data values
  foreach( $config['arguments'] as $name => &$value ) {
    $value = _y__token_data( $value );
  }

  // Make the query
  $basetable = reset($config['base table']);
  $basetablealias = $config['base table'][$basetable];
  $query = db_select( $basetable, $basetablealias );
  foreach( $config['build'] as $querycfg ) {
    foreach( $querycfg as $db_op => $args ) {
      _y__var_substitute($args, $config['arguments']);
      if ( in_array($db_op, array( 'addExpression',
        'addField',
        'addJoin',
        'extend',
        'innerJoin',
        'join',
        'leftJoin',
        'rightJoin', ) ) ) {
        $query = call_user_func_array(array($query, $db_op), $args);
      }
      else {
        call_user_func_array( array($query, $db_op), $args);
      }
    }
  }
  return $query;
}

/**
 * Execute a query and display and return results
 * @param $config array of query, arguments, and display
 *   query:
 *     base table:
 *       base_table_name: base_table_name_alias
 *     arguments:
 *       name_of_arg: definition_of_arg (see y__q_datagetter for how to define this
 *     query:
 *     - operation: arguments
 *       differentoperation: arguments
 *     - operation: morearguments...
 *   display:
 *     display callback: name of a function to process the results of the query
 * @return array
 */
function y__db_query_display($config) {
  $args = func_get_args();
  $ret = array();
  
  foreach ($args as $config) {
    if (empty($config['query']) || !($query = y__query_build($config['query']))) {
      return array();
    }
    $querystring = _y__query_get_string($query);
    $queryresult = $query->execute()->fetchAll();

    // Return results or display output
    if ($displayfunction = y__plugin($config, 'display', 'callback')) {
      $ret[] = call_user_func_array($displayfunction, array(
        $queryresult,
        $config['display']['arguments'] ?? NULL
      )); // todo: rework callback
    }
    else {
      $ret[] = $queryresult->fetchAllKeyed();
    }
  }

  if( (count($ret) == 1) && is_integer($key = key($ret)) ) {
    return $ret[$key];
  }
  return $ret;
}

function _y__page_context( $context ) {
  return NULL;
}

function _y__page_render($renderinfo, & $context) {
  if( !is_array($renderinfo) ) {
    return $renderinfo;
  }
  $ret = array();
  foreach( $renderinfo as $key => $value ) {
    if( is_integer($key) ) {
      $ret[$key] = _y__page_render( $value, $context );
    } else {
      switch ($key) {
        case 'function':
          if (isset($renderinfo['uri'])) {
            include_once $renderinfo['uri'];
          }
          $arguments = $renderinfo['arguments'] ?? array();
          $ret += $value($arguments); // must return an array
          break;
        case 'uri':
        case 'arguments':
          if (isset($renderinfo['function'])) {
            break; // gets used above
          }
        default:
          $ret[$key] = _y__page_render($value, $context);
      }
    }
  }
  return $ret;
}

function y__page_display($id, $module=NULL) {
  $ret = array( "#type" => 'page' );
  $pagedefs = y__protocol('page', 'layout', $module);
  $context = isset($pagedefs[$id]['context']) ? _y__page_context($pagedefs[$id]['context']) : array();
  foreach( $pagedefs[$id]['render'] as $key => $pagedef ) {
    $ret[$key] = _y__page_render($pagedef, $context);
  }
  return $ret;
}