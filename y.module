<?php

// include field management functionality
require_once 'y.fieldmgt.inc';

// include YAML callback functions
require_once 'y.yamlcallables.inc';

/**
 * Implements hook_hook_info().
 */
function y_hook_info() {
  return array( 'y' => array( 'group' => 'y') );
}

/** Array flattening / unflattening ************************/

/**
 * Flatten an array to one-dimensional with keys imploded with delimiter
 * @param array $array   // array to be flattened
 * @param string $prefix // current prefix for key
 * @param string $delim  // glue delimiter for key
 * @param null $ret      // array to put result in
 * @return array|null    // returns current level of array
 */
function y__array_flatten( array $array, $prefix='', $delim = ':', &$ret=NULL ) {
  if( $ret === NULL ) {
    $ret = array();
  }
  foreach( $array as $key => $value ){
    if( is_array($value) && $value ) {
      y__array_flatten( $value, $prefix . $key . $delim, $delim, $ret );
    } else {
      $ret[ $prefix . $key ] = $value;
    }
  }
  return( $ret );
}

/**
 * Unflatten 1D array into multi-dimensional
 * @param $prefix
 * @param $array / one-dimensional
 * @param string $glue
 */
function y__array_unflatten( array $array, $delim = ':') {
  $ret = array();
  foreach($array as $key => $value) {
    $workret = &$ret;
    $deepkeys = explode( $delim, $key );
    $finalkey = array_shift($deepkeys);
    foreach( $deepkeys as $curkey ) {
      if( !isset($workret[$finalkey] ) ) {
        $workret[$finalkey] = array();
      }
      $workret = &$workret[$finalkey];
      $finalkey = $curkey;
    }
    $workret[$finalkey] = $value;
  }
  return $ret;
}

/** Main YAML retrieval ************************************/

/**
 * Register a directory to load extra Y config information (not in default set of installed modules)
 * Can be in a theme, library, or for hook_schema a recently uninstalled module
 * @param array $extraconfiginfo
 */
function y__register_extra_config( array $extraconfiginfo ) {
  $override = & drupal_static('y__extra_config', array());
  foreach( $extraconfiginfo as $name => $configinfo ) {
    if( !isset($override[$name]) ) {
      $override[$name] = $configinfo + array('protocols implemented' => array(), 'path' => '.');
      $override[$name]['path'] = rtrim($override[$name]['path'], "/\\") . '/' ;
    }

  }
}

/**
 * Fetch all of the information defined by the owning module according to the protocol
 * This is the meat of it all
 * @param null $owner
 * @param $protocol
 * @return array of protocol information keyed by module implementing protocol
 */
function y__info( $protocol, $owner = NULL, $format='tree' ) {
  $modulesimplement = &drupal_static(__FUNCTION__ . ':modulesimplement', NULL);
  // An array keyed by protocol of the modules implementing the protocol
  // Eg. $modulesimplement['hook'] = array( 'bc', 'bcfeeds' )

  $protocolsimplemented = &drupal_static(__FUNCTION__ . ':protocolsimplemented', array());
  // An array keyed by modulename of the protocols implemented by the module
  // Eg. $protocolsimplemented['bc'] = array( 'hook', 'entity', 'bctype' );

  $newinfo = FALSE; // semaphore to know when yinfo has new information to be cached.
  $yinfo = &drupal_static(__FUNCTION__, array());
  // A multi-dim array of the modules implementing protocols keyed by protocol and module
  // Eg. $yinfo[$protocol][$module] = array(... )
  $configinfo = & drupal_static('y__extra_config', array());
  if( $modulesimplement === NULL ) {
    foreach( module_implements('y') as $module ) {
      if( !($path = drupal_get_path('module', $module)) ) {
        $path = '.';
      }
      $configinfo[$module] = array(
        'protocols implemented' => module_invoke($module, 'y'),
        'path' => $path . '/'
      );
    }
  }
  foreach ($configinfo as $module => $info ) {
    $protocols = $info['protocols implemented'];
    $protocolsimplemented[$module] = $protocols;
    foreach( $protocols as $p ) {
      if( isset($modulesimplement[$p]) ) {
        if( !in_array($module, $modulesimplement[$p])) {
          $modulesimplement[$p][] = $module;
        }
      } else {
        $modulesimplement[$p] = array( $module );
      }
    }
  }
  if( $owner ) {
    if( !isset($protocolsimplemented[$owner]) ) {
      $warning = t('Protocol !protocol requested  of module !module that provides none.', array(
        '!protocol' => $protocol, '!module' => $owner
      ));
    } else {
      if( !in_array($protocol, $protocolsimplemented[$owner]) ) {
        $warning = t('Protocol !protocol requested  of module !module that does not support it.', array(
          '!protocol' => $protocol, '!module' => $owner
        ));
      }
    }
  }
  if( !isset($modulesimplement[$protocol]) ) {
    return array();
  }
  if( isset($warning) ) {
    watchdog('Y', $warning);
    drupal_set_message('Y: ' . $warning, 'error');
    return array();
  }
  $modules = $owner ? array($owner) : $modulesimplement[$protocol];
  if( !$modules ) {
    return( array() );
  }

  $y_cache_flag = variable_get('y_cache_flag', TRUE);
  if( !$yinfo ) {
    if( $y_cache_flag && ($cache = cache_get(__FUNCTION__))) {
      $yinfo = $cache->data;
    }
  }

  if( $owner && isset($yinfo[$protocol][$owner]) ) {
    return $format ? $yinfo[$protocol][$owner][$format] : $yinfo[$protocol][$owner];
  }
  
  foreach( $modules as $module ) {
    $callbacks = array(
      '!t' => 'y__yaml_callback_t',
      '!module' => 'y__yaml_callback_plugin_module',
      '!path' => 'y__yaml_callback_plugin_path',
      '!relativepath' => 'y__yaml_callback_plugin_relativepath',
      '!name' => 'y__yaml_callback_plugin_name',
      '!local' => 'y__yaml_callback_plugin_local',
      '!call' => 'y__yaml_callback_call_user_func_array',
      '!var' => 'y__yaml_callback_var',
      '!setplugin' => 'y__yaml_callback_plugin_set',
      '!menucallback' => 'y__yaml_callback_plugin_menucallback',
      '!callback' => 'y__yaml_callback_plugin_callback',
      '!protocol' => 'y__yaml_callback_plugin_protocol',
      '!modulepath' => 'y__yaml_callback_plugin_modulepath',
      '!eval' => 'y__yaml_callback_eval',
    );
    // get config path for the module
    if( !isset($yinfo['_config'][$module] ) ) {
      $modulepath = $configinfo[$module]['path'];
      foreach( array($modulepath => $module . '.yaml', $modulepath . 'config/' => '_config.yaml') as $path => $filename ) {
        if (file_exists($path . $filename) ) {
          $filebase = pathinfo($filename, PATHINFO_FILENAME);
          _y__stack_push( 'y__yaml_plugin_values',
            array(
              'path' => $path,
              'module' => $module,
              'protocol' => '_config',
              'file' => $filebase . 'inc',
              'uri' => $path . $filebase . '.inc',
              'name' => $filebase, // 'bctype'
              'yaml uri' => $path . $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
              'filename' => $filename // 'bctype.yaml'
            ) );
          if((($_config = yaml_parse($path . $filename, 0, $n, $callbacks)) !== FALSE)) {
            if (!isset($_config['path'])) {
              $_config['path'] = $path;
              $_config['filename'] = $filename;
            }
            _y__stack_pop('y__yaml_plugin_values');
            break;
          }
          _y__stack_pop('y__yaml_plugin_values');
        }
      }
      $yinfo['_config'][$module] = $_config ?? array('path' => $path);
      $newinfo = TRUE;
    }
    if (!isset($yinfo[$protocol][$module]) ) {
      $conf = $yinfo['_config'][$module];
      $initarray = isset($yinfo['_config'][$module][$protocol]) ? $yinfo['_config'][$module][$protocol] : array();
      $filename = $conf['path'] . $protocol . '.yaml';
      // todo: find callbacks yaml and callbacks PHP if they will be found
      if( file_exists($filename) ) {
        _y__stack_push('y__yaml_plugin_values',
          array(
            'path' => $conf['path'],
            'module' => $module,
            'protocol' => $protocol,
            'file' => $protocol . '.inc',
            'uri' => $conf['path'] . $protocol . '.inc',
            'name' => $protocol, // 'bctype'
            'yaml uri' => $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $protocol . '.yaml' // 'bctype.yaml'
          ) );
        // $protocolinfo = (($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ? $info : $initarray);
        if( ($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ) {
          $protocolinfo = $info;
        } else {
          $protocolinfo = $initarray;
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $filename, 'warning');
        }
        _y__stack_pop('y__yaml_plugin_values');
      } else {
        $protocolinfo = $initarray; 
      }
      $yinfo[$protocol][$module] = $protocolinfo
        ? array( 'tree' => $protocolinfo,
                 'flat' => y__array_flatten($protocolinfo) )
        : array( 'tree' => array(), 'flat' => array() );
      $newinfo = TRUE;

      foreach (file_scan_directory($conf['path'] . $protocol, '|.*\.y.?ml|') as $file) {
        if( $path = dirname($file->uri) ) { $path .= '/'; }
        _y__stack_push('y__yaml_plugin_values',
          array(
            'path' => $path,
            'module' => $module,
            'protocol' => $protocol,
            'file' => $file->name . '.inc',
            'uri' => $path . $file->name . '.inc',
            'name' => $file->name, // 'bctype'
            'yaml uri' => $file->uri, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $file->filename // 'bctype.yaml'
         ) );
        if (($info = yaml_parse_file($file->uri, 0, $n, $callbacks)) !== FALSE) {
          $newinfo = TRUE;
          $yinfo[$protocol][$module] = array(
            'tree' => array_merge($yinfo[$protocol][$module]['tree'], $info ),
            'flat' => array_merge($yinfo[$protocol][$module]['flat'], y__array_flatten($info) ) );
        } else {
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $file->uri, 'warning');
        }
        _y__stack_pop('y__yaml_plugin_values');
      }
    }
  }
  if( $newinfo ) {
    drupal_alter('yinfo', $yinfo);
    if( $y_cache_flag ) {
      cache_set(__FUNCTION__, $yinfo);
    }
  }
  if( $owner ) {
    return isset($yinfo[$protocol][$owner][$format]) ? $yinfo[$protocol][$owner][$format] : array();
  } else {
    $ret = array();
    foreach( $yinfo[$protocol] as $name => $info ) {
      $ret = array_merge( $ret, $info[$format] );
    }
    return $ret;
  }
}

/** YAML build functions ***********************************/

/**
 * Build config array from patterns
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $patterns the patterns to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_pattern( $protocol, $module, $patterns, &$info=NULL ) {
  $yinfo = y__info( $protocol, $module, 'flat' );
  $buildflat = array();
  foreach( $patterns as $pattern => $filter ) {
    if( !is_array($filter) ) { // this is a simple pattern
      $pattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
      $mainpattern = $pattern;
      $mainreplacement = $filter;
    } else { // this is pure regex and all patterns and replacements are regex-perfect
      $mainpattern = array_keys($filter);
      $mainreplacement = array_values($filter);
    }
    $matchingkeys = preg_grep($pattern, array_keys($yinfo));
    $replacementkeys = preg_replace( $mainpattern, $mainreplacement, $matchingkeys );
    foreach( $matchingkeys as $index => $key ) {
      $buildflat[$replacementkeys[$index]] = $yinfo[$key];
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $info === NULL ) {
    return $buildflat;
  }
  $info = array_merge($info, $buildflat);
  return $info;
}

/**
 * Build branch array to root from pattern
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $pattern the pattern to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_branch( $module, $protocol, $pattern, &$info=NULL ) {
  $branchsearched = array();
  $yinfo = y__info( $protocol, $module, 'flat' );
  $buildflat = array();
  $childpattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
  $matchingkeys = preg_grep($childpattern, array_keys($yinfo));
  foreach( $matchingkeys as $key ) {
    $buildflat[$key] = $yinfo[$key];
    if( ($colpos = strrpos($key, ':')) !== FALSE ) {
      $key = substr($key, 0, $colpos);
      if( empty($branchsearched[$key]) ) {
        $branchsearched[$key] = TRUE;
        while( ($colpos = strrpos($key, ':')) !== FALSE ) {
          $key = substr($key, 0, $colpos);
          $parentpattern = '|^' . $key . ':([^:]*?)$|';
          $parentkeys = preg_grep($parentpattern, array_keys($yinfo));
          foreach ($parentkeys as $parentkey) {
            if (!isset($buildflat[$parentkey])) {
              $buildflat[$parentkey] = $yinfo[$parentkey];
            }
            else {
              $key = '';
              break;
            }
          }
        }
      }
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $info === NULL ) {
    return $buildflat;
  }
  $info = array_merge($info, $buildflat);
  return $info;
}

/** Packaged YAML protocol controllers *********************/

/**
 * Iterate through a set of protocols and get an array of all the api information in them.
 * @param array $protocols
 * @param $api
 * @param $module
 * @param squishiness
 * @return array
 */
function y__protocol_get_all( $protocols, $api, $module, $squishiness=0 ) {
  if( !is_array($protocols) ) {
    $protocols = array($protocols);
  }
  $ret = array();
  foreach( $protocols as $protocol ) {
    $yinfo = y__protocol( $protocol, $api, $module );
    $ret += $yinfo;
  }
  if( $squishiness ) { // squishiness does a quick union of subarrays
    if( $squishiness > 0 ) {
      while( $squishiness-- ) {
        foreach( $ret as $key => $value) {
          if( is_array($value) ) {
            unset( $ret[$key]);
            $ret += $value;
          }
        }
      }
    }
  }
  return $ret;
}

/**
 * Main y controller router
 * @param $protocol
 * @param ... more parameters
 * @return array of protocol information supplied by controller
 */
function y__protocol(string $protocol, string $api, $module=NULL, array &$info=NULL) {
  static $addonprotocolsfetched = FALSE;
  static $protocoldef = array(
    'instance' => array(),
    'field' =>    array(),
    'protocol' => array(),
    'entity' => array(
      'schema' => array(
        'pattern' => array(
          "*:schema:" => '$1:$2',
          "*:description" => '$1:description',
          "*:properties:*:schema:" => '$1:fields:$2:$3' ) ),
      'property info alter' => array(
        'pattern' => array(
          "*:properties:*:info:" => '$1:properties:$2:$3' ) ),
    ),
  );
  if( !isset($info) ) {
    $info = array();
  }
  if( !isset($protocoldef[$protocol]) ) {
    if( !$addonprotocolsfetched ) {
      $protocoldef += y__info('protocol');
      $addonprotocolsfetched = TRUE;
    }
    if( !isset($protocoldef[$protocol]) ) { // if still not set after retrieving protocols, set an empty stub
      $protocoldef[$protocol] = array();
    }
  }
  $protocol_instructions = $protocoldef[$protocol][$api] ?? ($protocoldef[$protocol]['default'] ?? array( 'array' => '+' ));
  foreach( $protocol_instructions as $buildtype => $patterns ) {
    switch( $buildtype ) {
      case 'pattern':
        y__build_pattern($protocol, $module, $patterns, $info);
        break;
      case 'array':
      default:
        $yinfo = $yinfo ?? y__info($protocol, $module);
        foreach ($yinfo as $key => $apiinfo) {
          if( isset($apiinfo[$api]) ) {
            $info[$key] = $info[$key] ?? array();
            switch ($patterns) {
              case '+':
                $info[$key] += $apiinfo[$api];
                break;
              case 'merge':
                $info[$key] = array_merge($info[$key], $apiinfo[$api]);
                break;
              default:
                if (function_exists($patterns)) {
                  $info[$key] = call_user_func($patterns, $info[$key], $apiinfo[$api]);
                }
                break;
            }
          }
        }
        break;
    }
  }
  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 * This may or may not be a good idea...
 * It is a demonstration of how y can automatically implement hooks for subscribing modules.
 * In this case, y will implement hook_entity_property_info_alter() for any module
 * implementing an entity using y -- one less hook to implement.
 * It would be quite easy to do this with MANY superfluous hooks.
 */
function y_entity_property_info_alter(&$info) {
  y__protocol('entity', 'property info alter', NULL, $info );
}

/** Function does nothing and can be passed as default to y__plugin so result is guaranteed to be callable */
function _y__donothing() {
  return;
}

/**
 * Plugin functionality
 * if '_y__donothing' passed as default, then it always returns a valid callable function name
 * callback is of form:
 *   callbackname: name_of_function OR
 *   callbackname:
 *     function: name_of_function
 *     uri: file_containing_function_definition
 * @param $info an array of configuration information (eg. all the form information associated with an entity) 
 * @param $type a selector into that array (eg. the bundle name using a form) (use NULL if $info has the callbackname directly)
 * @param $callbackname the callback name (eg. form validation)
 * @param string $default (eg. the name of a default function to be returned if nothing else pans out)
 * @return string the name of a callable function or the default (which may be a callable function name)
 */
function y__plugin( array $info, string $type, string $callbackname, $default='' ): string {
  $callback = ($type === NULL)
    ? $info[$callbackname] ?? $default
    : $info[$type][$callbackname] ?? $default;
  if( $callback ) {
    if( is_array( $callback ) ) {
      if (!empty($callback['uri']) && file_exists($callback['uri'])) {
        require_once $callback['uri'];
      }
      $callbackname = $callback['function'] ?? $default;
    } else {
      $callbackname = $callback;
    }
  } else {
    $callbackname = $default;
  }
  $ret = function_exists($callbackname) ? $callbackname : $default;
  return $ret;
}

/**
 * Implements hook_init() and instantiates all Drupal hooks defined with the "hook" protocol
 * Another demonstration of how y can implement hooks for subscribing functions, it can do
 * hook_menu, hook_permission, and even do them dynamically, implementing the hooks as they are
 * discovered.
 * This is probably a really, super, bad idea and that's why it's commented, but it's pretty
 * cool. If y were incorporated into core, these sorts of things could happen automatically
 * at that level.
function _y_init() {
  // Instantiate YAML-defined local hooks
  if ( ($hookfunctiondefs = cache_get(__FUNCTION__)) === FALSE) {
    $hookfunctiondefs = new stdClass();
    $hookfunctiondefs->data = '';

    if ($hookdef = y__protocol_hook(NULL, 'local hooks')) {
      foreach ($hookdef as $hookmodule => $hooks) {
        foreach ($hooks as $hookname => $hookinfo) {
          $hookfunctiondefs->data .= "\nfunction " . $hookmodule . '_' . $hookname . '(){return ' . var_export($hookinfo, TRUE) . ';}';
        }
      }
      cache_set(__FUNCTION__, $hookfunctiondefs->data);
    }
  }
  if (!empty($hookfunctiondefs->data)) {
    try {
      eval($hookfunctiondefs->data);
    }
    catch (ParseError $e) { // got to clear the error-full statement to be able to move forward.
      cache_set( __FUNCTION__, FALSE );
      _drupal_exception_handler( $e );
    }
  }
}
*/

/**
 * Query / display functionality
 */
function y__display_array($table) {
  $args = func_get_args();
  $output = array();
  foreach( $args as $key => $value ) {
    $output[] = array(
      '#title' => $key,
      '#type' => 'textfield',
      '#value' => (string) $value,
    );
  }
  return $output;
}

/**
 * Recursively substitute special patterns in array
 * @param $var
 * @param $substarray
 */
function _y__var_substitute( & $var, $substarray ) {
  if( !is_array($var) ) {
    if( in_array($var, array_keys($substarray), TRUE) ) {
      $var = $substarray[$var];
    } elseif( is_string($var) ) {
      $var = strtr( $var, $substarray );
    }
  } else {
    foreach( $var as & $value ) {
      _y__var_substitute( $value, $substarray );
    }
  }
  return $var;
}

/**
 * Display a query result set as a table using the given render rules
 * @param $resultset   // stuff to display, array of arrays or objects
 * @param null $render // settings to initialize output
 * @return array|null  // table render array
 */
function y__display_table( $resultset, $rowaccess, $colaccess, $render=NULL ) {
  if( !$render ) {
    $render = array(
                'querytable' => array(
                  '#empty' => t('No results'), ) );
  }
  $format_def = reset($render);
  $name = key($render);
  $header = $format_def['#header'] ?? array();
  $row_def = $format_def['#rows'] ?? array();
  $tokens = array();
  $rows = array();

  foreach( $resultset as $result ) {
    $result = (array)$result;
    if( !$tokens ) {
      $tokens = array_keys($result);
      foreach( $tokens as &$token ) {
        $token = '[' . $token . ']';
      }
    }
    if (!$header) {
      $header = array_combine(array_keys($result), array_keys($result));
    }
    if( !$row_def ) {
      $rows[] = $result;
    } else {
      $rows[] = _y__var_substitute($row_def, array_combine($tokens,array_values($result)));
    }
  }
  $render[$name] = array_merge( $render[$name],
    array(
      '#theme' => 'table',
      '#header' => $header,
      '#rows' => $rows,
    )
  );
  return $render;
}

/**
 * Build an array of tokens in form token=>'[token]' for substitution-handling
 * @param array $tokens
 * @return array
 */
function y__token_build_list( array $tokens ) {
  $ret = array();
  foreach( $tokens as $token ) {
    $ret[$token] = '[' . $token . ']';
  }
  return $ret;
}

/**
 * Display a query result set as a table using the given render rules
 * @param $resultset   // stuff to display, array of arrays or objects
 * @param null $render // settings to initialize output
 * @return array|null  // table render array
 */
function y__display_queryresults_inline( $resultset, $config ) {
  $solo = (array) reset($resultset);
  $tokens = y__token_build_list(array_keys($solo));
  $config += array( 'render' => array(), 'rowaccess' => array(), 'colaccess' => array() );
  $rowaccess = $config['rowaccess'];
  $colaccess = $config['colaccess'];
  $render = $config['render'];
  $row_def = $config['render']['rows'] ?? array_keys($tokens);
  $rows = array();

  foreach( $resultset as $result ) {
    $result = (array)$result;
    $substitution = array_combine($tokens,array_values($result));
    if( isset($rowaccess['callback']) ) {
      $args = array( $result ) + $rowaccess['arguments'] ?? array();
      if( !call_user_func_array($rowaccess['callback'], $args) ) {
        continue;
      }
    }
    $defined_row = $row_def;
    $row = _y__var_substitute($defined_row, $substitution);
    if( isset($colaccess['callback']) ) {
      if( $function = y__plugin($colaccess, 'callback') ) {
        $args = array( $row_def, $row );
        if( !empty($colaccess['arguments'])) {
          $args = array_merge($args, $colaccess['arguments']);
        }
        $row = call_user_func_array($function, $args);
      }
    }
    $rows[] = $row;
  }
  $header_def = $render['header'] ?? array();
      // '#theme' => 'fieldset',
      // '#empty' => t('No results'), );
  $footer_def = $render['footer'] ?? array();
  if( isset($substitution)) {
    $header_def = _y__var_substitute($header_def, $substitution);
    $footer_def = _y__var_substitute($footer_def, $substitution);
  }
  $render = array( 'header' => $header_def, 'rows' => $rows, 'footer' => $footer_def );
  return $render;
}

/**
 * Display a query result set as a table using the given render rules
 * @param $resultset   // stuff to display, array of arrays or objects
 * @param null $render // settings to initialize output
 * @return array|null  // table render array
 */
function y__display_queryresults( $resultset, $config ) {
  $solo = (array) reset($resultset);
  $tokens = y__token_build_list(array_keys($solo));
  $context = $config['protocol']['context'] ?? array();
  $config +=  array(
    'rowaccess' => array(),
    'colaccess' => array() );
  $rowaccess = $config['rowaccess'];
  $colaccess = $config['colaccess'];

  $row_def = $config['render']['iterate'] ?? array_values( $tokens );
  $rows = array();

  foreach( $resultset as $result ) {
    $result = (array)$result;
    $substitution = array_combine($tokens,array_values($result)) + $context;
    if( isset($rowaccess['callback']) ) {
      $args = array( $result ) + $rowaccess['arguments'] ?? array();
      if( !call_user_func_array($rowaccess['callback'], $args) ) {
        continue;
      }
    }
    $defined_row = $row_def;
    $row = _y__var_substitute($defined_row, $substitution);
//    if( isset($colaccess['callback']) ) {
//      if( $function = y__plugin($colaccess, 'callback') ) {
//        $args = array( $row_def, $row );
//        if( !empty($colaccess['arguments'])) {
//          $args = array_merge($args, $colaccess['arguments']);
//        }
//        $row = call_user_func_array($function, $args);
//      }
//    }
    $rows[] = $row;
  }
  if( !isset($substitution) ) {
    $substitution = $context;
  }
  $substitution['[@iteration]'] = $rows;
  $substitution['[@keys]'] = array_keys($solo);
  $substitution['[@values]'] = array_values($solo);
  $substitution = array_merge($substitution, $context);

  $render = $config['render']['content'] ?? array( 
      "#theme" => 'table', "#empty" => t('No results'),
      "#header" => '[@keys]', '#rows' => '[@iteration]');
  $render = _y__var_substitute($render, $substitution );
  return $render;
}

/**
 * transform a token of a particular type into its values
 * @param $token of form
 *   global: globalvarname: globalvarproperty OR
 *           globalvarname
 * @return token value if successful, null if unsuccessful
 */
function _y__token_data( array $token ) {
  $value = reset( $token );
  $method = key($token);
  switch ( $method ) {
    case 'arg': // return a value at a numerical index into a context array
      $args = & drupal_static(__FUNCTION__, array());
      return $args[$value];
    case 'global': // return a global variable value
      if (is_array($value)) {
        $varprop = reset($value);
        $varname = key($value);
        global $$varname;
        return $$varname->$varprop;
      }
      else {
        global $$value;
        return $$value;
      }
      break;
    case 'session': // return a session variable value
      return $_SESSION[$value];
      break;
    case 'callback': // return the result of a callback
      if( is_array($value) ) {
        $name = key($value);
        if( is_integer($name) ) {
          $function = reset($value);
          $args = array();
        } else {
          $function = $name;
          if( !($args = reset($value)) ) {
            $args = array();
          }
        }
      } else {
        $function = $value;
        $args = array();
      }

      return call_user_func_array( $function, $args );
  }

  return NULL;
}

// Helper function to show a query string
function _y__query_get_string(SelectQueryInterface $query) {
  $string = (string) $query;
  $arguments = $query->arguments();

  if (!empty($arguments) && is_array($arguments)) {
    foreach ($arguments as $placeholder => &$value) {
      if (is_string($value)) {
        $value = "'$value'";
      }
    }

    $string = strtr($string, $arguments);
  }

  return $string;
}

/**
 * Build a query from a query definition array
 * @param $config
 * @return array
 */
function y__query_build( $config ) {
  if( empty($config['base table'])) {
    return array();
  }

  $config += array( 'arguments' => array(), 'build' => array() );
  // Get data values
  $substitution = $config['protocol']['context'] ?? array();
  foreach( $config['arguments'] as $name => $value ) {
    $substitution[$name] = _y__token_data( $value );
  }

  // Make the query
  $basetable = reset($config['base table']);
  $basetablealias = $config['base table'][$basetable];
  $query = db_select( $basetable, $basetablealias );
  foreach( $config['build'] as $querycfg ) {
    foreach( $querycfg as $db_op => $args ) {
      _y__var_substitute($args, $substitution);
      if ( in_array($db_op, array( 'addExpression',
        'addField',
        'addJoin',
        'extend',
        'innerJoin',
        'join',
        'leftJoin',
        'rightJoin', ) ) ) {
        $query = call_user_func_array(array($query, $db_op), $args);
      }
      else {
        call_user_func_array( array($query, $db_op), $args);
      }
    }
  }
  return $query;
}

/**
 * Execute a query and display and return results
 * @param $config array of query, arguments, and display
 *   query:
 *     base table:
 *       base_table_name: base_table_name_alias
 *     arguments:
 *       name_of_arg: definition_of_arg (see y__q_datagetter for how to define this
 *     query:
 *     - operation: arguments
 *       differentoperation: arguments
 *     - operation: morearguments...
 *   display:
 *     display callback: name of a function to process the results of the query
 * @return array
 */
function y__views() {
  $args = func_get_args();
  $ret = array();
  $views = array_shift($args);
  if( !is_array($views) ) {
    $views = array( $views );
  }
  drupal_static('_y__token_data', $args, TRUE);

  foreach ($views as $config) {
    if (empty($config['query']) || !($query = y__query_build($config['query']))) {
      return array();
    }
    $querystring = _y__query_get_string($query);
    $queryresult = $query->execute()->fetchAll();

    // Return results or display output
    if (!($displayfunction = y__plugin($config, 'display', 'callback'))) {
      $displayfunction = 'y__display_queryresults';
    }
    $render = call_user_func_array($displayfunction, array(
      $queryresult,
      $config['display'] ?? array()
    ));
    $ret[] = $render;
  }

  if( (count($ret) == 1) && is_integer($key = key($ret)) ) {
    return $ret[$key];
  }
  return $ret;
}

function _y__page_context( $context ) {
  return NULL;
}

function _y__page_render($renderinfo, & $context) {
  if( !is_array($renderinfo) ) {
    return $renderinfo;
  }
  $ret = array();
  foreach( $renderinfo as $key => $value ) {
    if( is_integer($key) ) {
      $ret[$key] = _y__page_render( $value, $context );
    } else {
      switch ($key) {
        case 'protocol': break;
        case 'function':
          if (isset($renderinfo['uri'])) {
            include_once $renderinfo['uri'];
          }
          $arguments = $renderinfo['arguments'] ?? array();
          $ret += $value($arguments); // must return an array
          break;
        case 'uri':
        case 'arguments':
          if (isset($renderinfo['function'])) {
            break; // gets used above
          }
        default:
          $ret[$key] = _y__page_render($value, $context);
      }
    }
  }
  return $ret;
}

function y__page_display($id, $module=NULL) {
  $ret = array( "#type" => 'page' );
  $pagedefs = y__protocol('page', 'layout', $module);
  $context = isset($pagedefs[$id]['context']) ? _y__page_context($pagedefs[$id]['context']) : array();
  foreach( $pagedefs[$id]['render'] as $key => $pagedef ) {
    $ret[$key] = _y__page_render($pagedef, $context);
  }
  return $ret;
}

/**
 * Implements hook_menu().
 */
function y_menu() {
  return array(
    'admin/config/development/y' => array(
      'title' => 'YAML configuration',
      'description' => 'Configure YAML configuration',
      'page callback' => 'drupal_get_form',
      'page arguments' => array( 'y__config_form' ),
      'access arguments' => array( 'administer site configuration' ),
    )
  );
}

function y__config_form($form, &$form_state) {
  $form['y_cache_flag'] = array(
    '#type' => 'checkbox',
    '#title' => t('YAML Configuration caching'),
    '#default_value' => variable_get('y_cache_flag', TRUE),
    '#description' => t('Turn YAML configuration caching on and off.')
  );

  return system_settings_form($form);
}

function y__emit($elements) {
  if( FALSE ) { // hooked in at drupal_render, just set true to start emitting stuff
    if (!$elements) {
      return;
    }
    $index = variable_get('yaml_render', 1);
    $type = '';
    if (isset($elements['#type'])) {
      $type = 'type_' . $elements['#type'];
    }
    else {
      if (isset($elements['#theme'])) {
        $type = 'theme_';
        if (is_array($elements['#theme'])) {
          $type .= implode('_', $elements['#theme']);
        }
        else {
          $type .= $elements['#theme'];
        }
      }
      else {
        if (isset($elements['#theme_wrappers'])) {
          $type = 'wrap_';
          if (is_array($elements['#theme_wrappers'])) {
            $type .= implode('_', $elements['#theme_wrappers']);
          }
          else {
            $type .= $elements['#theme_wrappers'];
          }
        }
      }
    }

    yaml_emit_file('yaml/' . str_pad($index, 4, '0', STR_PAD_LEFT) . '_' . $type . '.yaml', $elements);
    variable_set('yaml_render', ++$index);
  }
}