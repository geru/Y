<?php

// include field management functionality
require_once 'y.fieldmgt.inc';

/**
 * Implements hook_hook_info().
 */
function y_hook_info() {
  return array( 'y' => array( 'group' => 'y') );
}

/** YAML parsing callbacks *********************************/

/**
 * YAML parse callback general function call
 * @return mixed|null
 */
function y__yaml_callback_call_user_func_array( $value, $tag, $flags ) {
  if( is_array($value) ) {
    $function = array_shift($value);
  } else {
    $function =  $value;
    $value = array();
  }
  return function_exists($function) ? call_user_func_array($function, $value) : NULL;
}

/**
 * YAML parse callback Drupal t() translate
 * @return mixed|null
 */
function y__yaml_callback_t( $value, $tag, $flags ) {
  return t($value);
}

function y__yaml_callback_eval( $value, $tag, $flags ) {
  $ret = array();
  if( !is_array($value) ) {
    $value = array( $value );
  }
  foreach( $value as $key => $evalline ) {
    $evalline = '$ret[$key]=' . $evalline . ';';
    eval($evalline);
  }
  $retval = ((count($ret) == 1) && is_numeric($key)) ? reset($ret) : $ret;
  return $retval;
}

/**
 * YAML parse callback general variable functionality
 * @return mixed|null
 */
function y__yaml_callback_var( $value, $tag, $flags ) {
  static $idx = 0;
  $staticvar = & drupal_static( 'y__static ' . $tag, array() );

  if( !is_array($value) ) {
    $staticvar[$idx] = $value;
  } else {
    foreach( $value as $opcode => $target ) {
      if( is_numeric($opcode) ) {
        $translate = array( '++' => 'inc', 'inc' => 'inc',
          '--' => 'dec', 'dec' => 'dec');
        $opcode = $translate[$target] ?? NULL;
        $target = $opcode ? 0 : 1;
      }
      switch( $opcode ) {
        case 'inc':
        case '+':
          $staticvar[$idx] = $staticvar[$idx] + $target;
          break;
        case 'dec':
        case '-':
          $staticvar[$idx] = $staticvar[$idx] - $target;
          break;
        default:
          $staticvar[$opcode] = $target;
      }
    }
  }
  return $staticvar;
}

// push var onto top of the stack
function _y__stack_push( $stackname, $var ) {
  $stack = & drupal_static($stackname, array());
  array_push($stack, $var);
}

// pop top element off stack
function _y__stack_pop( $stackname ) {
  $stack = & drupal_static($stackname, array());
  return array_pop($stack);
}

// get value of current stop of stack
function _y__stack_peek( $stackname ) {
  $stack = & drupal_static($stackname, array());
  return end($stack);
}

// change current element at top of stack (equiv of pop then push
function _y__stack_set( $stackname, $var ) {
  $stack = & drupal_static($stackname, array());
  array_pop($stack);
  array_push($stack, $var);
}

/**
 * YAML parse callback Set a plugin value
 * @return mixed|null
 */
function y__yaml_callback_plugin_set( $value, $tag, $flags ) {
  //$plugin = & drupal_static('y__yaml_plugin_values', array());
  $plugin = & _y__stack_peek('y__yaml_plugin_values');
  $plugin = array_merge( $plugin, $value );
  return $value;
}

/**
 * YAML parse callback set info for menu API discoverable plugin
 * @return mixed|null
 * */
function y__yaml_callback_plugin_menucallback( $value, $tag, $flags ) {
  $plugin = _y__stack_peek('y__yaml_plugin_values');
  $includefilearray = array(  'file' => $plugin['file'],
                              'file path' => $plugin['path'] );
  $ret = $value + $includefilearray;
  return $ret;
}

function y__yaml_callback_plugin_callback( $value, $tag, $flags ) {
  $result = array();
  $includefilearray = array();
  // $plugin = & drupal_static('y__yaml_plugin_values', array());
  $plugin = _y__stack_peek('y__yaml_plugin_values');
  if( !is_array($value)) {
    $result['function'] = $value;
    $includefilearray['uri'] = $plugin['uri']; 
  } else {
    if( !empty($value['plugin']) ) {
      $keys = is_array($value['plugin']) ? $value['plugin'] : array($value['plugin']);
      foreach( $keys as $key ) {
        $includefilearray[$key] = $plugin[$key];  
      }
      unset( $value['plugin'] );
    } 
    $result = $value;
  }
  $result += $includefilearray;
  return $result;
}

function y__yaml_callback_plugin_protocol( $value, $tag, $flags ) {
  // $plugin = & drupal_static('y__yaml_plugin_values', array());
  $plugin = _y__stack_peek('y__yaml_plugin_values');
  $params = $value + $plugin;
  $yinfo = y__protocol( $params['target'], $params['module'], $params['api'] );
  $ret = $yinfo[$params['id']] ?? array();
  return $ret;
}

/**
 * Set plugin values
 * @param array $initarray

function y__yaml_plugin_values( $initarray=array() ) {
  $plugin = & drupal_static('y__yaml_plugin_values', array());
  $plugin = $initarray;
}
*/
/** Array flattening / unflattening ************************/

/**
 * Flatten an array to one-dimensional with keys imploded with delimiter
 * @param array $array   // array to be flattened
 * @param string $prefix // current prefix for key
 * @param string $delim  // glue delimiter for key
 * @param null $ret      // array to put result in
 * @return array|null    // returns current level of array
 */
function y__array_flatten( array $array, $prefix='', $delim = ':', &$ret=NULL ) {
  if( $ret === NULL ) {
    $ret = array();
  }
  foreach( $array as $key => $value ){
    if( is_array($value) && $value ) {
      y__array_flatten( $value, $prefix . $key . $delim, $delim, $ret );
    } else {
      $ret[ $prefix . $key ] = $value;
    }
  }
  return( $ret );
}

/**
 * Unflatten 1D array into multi-dimensional
 * @param $prefix
 * @param $array / one-dimensional
 * @param string $glue
 */
function y__array_unflatten( array $array, $delim = ':') {
  $ret = array();
  foreach($array as $key => $value) {
    $workret = &$ret;
    $deepkeys = explode( $delim, $key );
    $finalkey = array_shift($deepkeys);
    foreach( $deepkeys as $curkey ) {
      if( !isset($workret[$finalkey] ) ) {
        $workret[$finalkey] = array();
      }
      $workret = &$workret[$finalkey];
      $finalkey = $curkey;
    }
    $workret[$finalkey] = $value;
  }
  return $ret;
}

/** Main YAML retrieval ************************************/

/**
 * Fetch all of the information defined by the owning module according to the protocol
 * @param null $owner
 * @param $protocol
 * @return array of protocol information keyed by module implementing protocol
 *
 * todo: add callback indexing and caching
 */
function y__info( $owner = NULL, $protocol, $format='tree' ) {
  $modulesimplement = &drupal_static(__FUNCTION__ . ':modulesimplement', NULL);
  // An array keyed by protocol of the modules implementing the protocol
  // Eg. $modulesimplement['hook'] = array( 'bc', 'bcfeeds' )

  $protocolsimplemented = &drupal_static(__FUNCTION__ . ':protocolsimplemented', array());
  // An array keyed by modulename of the protocols implemented by the module
  // Eg. $protocolsimplemented['bc'] = array( 'hook', 'entity', 'bctype' );

  $yinfo = &drupal_static(__FUNCTION__, array());
  // A multi-dim array of the modules implementing protocols keyed by protocol and module
  // Eg. $yinfo[$protocol][$module] = array(... )

  // Initialize self
  if( $modulesimplement === NULL ) { // todo: getting burned by this logic if hook not declared by hook_y()
    $modulesimplement = array();
    // any time a new protocol is requested, something has changed, clear information and reload
    //$modulesimplement = array();
    // $modulesimplement[$protocol] = array();
    // $protocolsimplemented = array();
  }
  if( !isset($modulesimplement[$protocol]) || ($owner && !isset($protocolsimplemented[$owner])) ) {
    $modules = module_implements('y');
    foreach ($modules as $module) {
      $protocolsimplemented[$module] = module_invoke($module, 'y');
      foreach ($protocolsimplemented[$module] as $p) {
        if (!isset($modulesimplement[$p])) {
          $modulesimplement[$p] = array();
        }
        $modulesimplement[$p][] = $module;
        if (!isset($yinfo[$p])) {
          $yinfo[$p] = array();
        }
      }
    }
  }
  $modules = $owner
    ? array($owner)
    : $modulesimplement[$protocol] ?? array();
  if( !$modules ) {
    return( array() );
  }
  //    $warning = t( 'Undeclared protocol !protocol requested. Owner: !owner.', array('!protocol' => $protocol, '!owner' => $owner));
  //    watchdog('Y', $warning);
  //    drupal_set_message('Y: ' . $warning, 'error');
  $backdoor = & drupal_static('y__backdoor_for_uninstall');
  if( $owner && !$backdoor ) {
    if (!isset($protocolsimplemented[$owner])) { // This happens for hook_schema... trouble
        return array();
    } else {
      if (!in_array($protocol, $protocolsimplemented[$owner])) {
        $warning = t('Protocol !protocol requested  of module !module that does not support it.', array(
          '!protocol' => $protocol,
          '!module' => $owner
        ));
        watchdog('Y', $warning);
        drupal_set_message('Y: ' . $warning, 'error');
      }
    }
  }
  if( isset($warning) ) {
    return array();
  }

  if( $owner && isset($yinfo[$protocol][$owner]) ) {
    return $format ? $yinfo[$protocol][$owner][$format] : $yinfo[$protocol][$owner];
  }

  foreach( $modules as $module ) {
    $callbacks = array(
      '!t' => 'y__yaml_callback_t',
      '!call' => 'y__yaml_callback_call_user_func_array',
      '!var' => 'y__yaml_callback_var',
      '!setplugin' => 'y__yaml_callback_plugin_set',
      '!menucallback' => 'y__yaml_callback_plugin_menucallback',
      '!callback' => 'y__yaml_callback_plugin_callback',
      '!protocol' => 'y__yaml_callback_plugin_protocol',
      '!eval' => 'y__yaml_callback_eval',
    );
    // get config path for the module
    if( !isset($yinfo['_config'][$module] ) ) {
      $modulepath = ($backdoor ?? drupal_get_path('module', $module)) . '/';
      foreach( array($modulepath => $module . '.yaml', $modulepath . 'config/' => '_config.yaml') as $path => $filename ) {
        if (file_exists($path . $filename) ) {
          $filebase = pathinfo($filename, PATHINFO_FILENAME);
          _y__stack_push( 'y__yaml_plugin_values',
            array(
              'path' => $path,
              'module' => $module,
              'protocol' => '_config',
              'file' => $filebase . 'inc',
              'uri' => $path . $filebase . '.inc',
              'name' => $filebase, // 'bctype'
              'yaml uri' => $path . $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
              'filename' => $filename // 'bctype.yaml'
            ) );
          if((($_config = yaml_parse($path . $filename, 0, $n, $callbacks)) !== FALSE)) {
            if (!isset($_config['path'])) {
              $_config['path'] = $path;
              $_config['filename'] = $filename;
            }
            _y__stack_pop('y__yaml_plugin_values');
            break;
          }
          _y__stack_pop('y__yaml_plugin_values');
        }
      }
      $yinfo['_config'][$module] = $_config ?? array('path' => $modulepath . 'config/');
    }
    if (!isset($yinfo[$protocol][$module]) ) {
      $conf = $yinfo['_config'][$module];
      $initarray = isset($yinfo['_config'][$module][$protocol]) ? $yinfo['_config'][$module][$protocol] : array();
      $filename = $conf['path'] . $protocol . '.yaml';
      // todo: find callbacks yaml and callbacks PHP if they will be found
      if( file_exists($filename) ) {
        _y__stack_push('y__yaml_plugin_values',
          array(
            'path' => $conf['path'],
            'module' => $module,
            'protocol' => $protocol,
            'file' => $protocol . '.inc',
            'uri' => $conf['path'] . $protocol . '.inc',
            'name' => $protocol, // 'bctype'
            'yaml uri' => $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $protocol . '.yaml' // 'bctype.yaml'
          ) );
        // $protocolinfo = (($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ? $info : $initarray);
        if( ($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ) {
          $protocolinfo = $info;
        } else {
          $protocolinfo = $initarray;
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $filename, 'warning');
        }
        _y__stack_pop('y__yaml_plugin_values');
      } else {
        $protocolinfo = $initarray; 
      }
      $yinfo[$protocol][$module] = $protocolinfo
        ? array( 'tree' => $protocolinfo,
                 'flat' => y__array_flatten($protocolinfo) )
        : array( 'tree' => array(), 'flat' => array() );

      foreach (file_scan_directory($conf['path'] . $protocol, '|.*\.y.?ml|') as $file) {
        _y__stack_push('y__yaml_plugin_values',
          array(
            'path' => $conf['path'] . $protocol . '/',
            'module' => $module,
            'protocol' => $protocol,
            'file' => $file->name . '.inc',
            'uri' => $conf['path'] . $protocol . '/' . $file->name . '.inc',
            'name' => $file->name, // 'bctype'
            'yaml uri' => $file->uri, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $file->filename // 'bctype.yaml'
         ) );
        if (($info = yaml_parse_file($file->uri, 0, $n, $callbacks)) !== FALSE) {
          $yinfo[$protocol][$module] = array(
            'tree' => array_merge($yinfo[$protocol][$module]['tree'], $info ),
            'flat' => array_merge($yinfo[$protocol][$module]['flat'], y__array_flatten($info) ) );
        } else {
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $file->uri, 'warning');
        }
        _y__stack_pop('y__yaml_plugin_values');
      }
    }
  }
  if( $owner ) {
    return isset($yinfo[$protocol][$owner][$format]) ? $yinfo[$protocol][$owner][$format] : array();
  } else {
    $ret = array();
    foreach( $yinfo[$protocol] as $name => $info ) {
      $ret = array_merge( $ret, $format == 'tree' ? array( $name => $info['tree'] ) : $info['flat'] );
    }
    return $ret;
  }
}

/** YAML build functions ***********************************/

/**
 * Build config array from patterns
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $patterns the patterns to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_pattern( $module, $protocol, $patterns, &$ret=NULL ) {
  $yinfo = y__info( $module, $protocol, 'flat' );
  $buildflat = array();
  foreach( $patterns as $pattern => $filter ) {
    if( !is_array($filter) ) { // this is a simple pattern
      $pattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
      $mainpattern = $pattern;
      $mainreplacement = $filter;
    } else { // this is pure regex and all patterns and replacements are regex-perfect
      $mainpattern = array_keys($filter);
      $mainreplacement = array_values($filter);
    }
    $matchingkeys = preg_grep($pattern, array_keys($yinfo));
    $replacementkeys = preg_replace( $mainpattern, $mainreplacement, $matchingkeys );
    foreach( $matchingkeys as $index => $key ) {
      $buildflat[$replacementkeys[$index]] = $yinfo[$key];
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $ret === NULL ) {
    return $buildflat;
  }
  $ret = array_merge($ret, $buildflat);
  return $ret;
}

/**
 * Build branch array to root from pattern
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $pattern the pattern to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_branch( $module, $protocol, $pattern, &$ret=NULL ) {
  $branchsearched = array();
  $yinfo = y__info( $module, $protocol, 'flat' );
  $buildflat = array();
  $childpattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
  $matchingkeys = preg_grep($childpattern, array_keys($yinfo));
  foreach( $matchingkeys as $key ) {
    $buildflat[$key] = $yinfo[$key];
    if( ($colpos = strrpos($key, ':')) !== FALSE ) {
      $key = substr($key, 0, $colpos);
      if( empty($branchsearched[$key]) ) {
        $branchsearched[$key] = TRUE;
        while( ($colpos = strrpos($key, ':')) !== FALSE ) {
          $key = substr($key, 0, $colpos);
          $parentpattern = '|^' . $key . ':([^:]*?)$|';
          $parentkeys = preg_grep($parentpattern, array_keys($yinfo));
          foreach ($parentkeys as $parentkey) {
            if (!isset($buildflat[$parentkey])) {
              $buildflat[$parentkey] = $yinfo[$parentkey];
            }
            else {
              $key = '';
              break;
            }
          }
        }
      }
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $ret === NULL ) {
    return $buildflat;
  }
  $ret = array_merge($ret, $buildflat);
  return $ret;
}

/** Packaged YAML protocol controllers *********************/

/**
 * Iterate through a set of protocols and get an array of all the api information in them.
 * @param array $protocols
 * @param $module
 * @param $api
 * @return array
 */
function y__protocol_get_all( $protocols, $module, $api ) {
  if( !is_array($protocols) ) {
    $protocols = array($protocols);
  }
  $ret = array();
  foreach( $protocols as $protocol ) {
    $ret += y__protocol( $protocol, $module, $api );
  }
  return $ret;
}

/**
 * @param string $path path to module, provides backdoor when uninstalling
 */
function y__modulepath_set_override( string $path ) {
  $modulepath = & drupal_static('y__backdoor_for_uninstall');
  $modulepath = $path;
}

/**
 * Main y controller router
 * @param $protocol
 * @param ... more parameters
 * @return array of protocol information supplied by controller
 */
function y__protocol() {
  $args = func_get_args();
  $tmparray = $args[3] ?? NULL;
  if( count($args) ) {
    $protocolcontroller = 'y__protocol_' . $args[0];
    if( isset($tmparray) ) { // this funkiness has to happen because call_user_func doesn't take references easily, see PHP manual
      $args[3] = &$tmparray;
    }
    if( function_exists($protocolcontroller) ) {
      array_shift( $args );
      return call_user_func_array($protocolcontroller, $args);
    }
    return call_user_func_array('_y__protocol_default', $args);
  }
  return array();
}

function _y__protocol_default( string $protocol, $module, string $api, array &$info=NULL) {
  $ret = $module && in_array($api, array('menu')) // this array is for hooks where every sub-element is unique, like permissions, or menu hooks
    ? y__build_pattern($module, $protocol, array("*:$api:" => '$2'), $info)
    : y__build_pattern($module, $protocol, array("*:$api:" => '$1:$2'), $info);
  return $ret;
}

/**
 * Implements protocol 'field'
 * Returns values defined by the y field protocol
 * Defined $api's:
 *   default: is anything in the 'definition' section
 * 
 * Implements:
 *   'local hook' generates local hooks
 */
function y__protocol_field($module, string $api, array &$info=NULL) {
  $ret = isset($info) ? $info : array();
  switch( $api ) {
    case 'schema':
      $ret = y__build_pattern($module, 'field', array("*:definition:$api:" => '$2'), $ret);
      break;
    default:
      $yinfo = y__info($module, 'field' );
      $ret += $yinfo[$module]['definition'][$api];
      break;
  }

  return $ret;
}

/**
 * Implements protocol 'instance'
 * Returns values defined by the y instance protocol
 */
function y__protocol_instance($module, string $api, array &$info=NULL) {
  $ret = y__build_pattern($module, 'instance', array("*:$api:" => '$1:$2'), $info);
  return $ret;
}

/**
 * Implements protocol 'entity'
 * Returns values defined by the y entity protocol
 */
function y__protocol_entity($module, string $api, array &$info = NULL) {
  switch( $api ) {
    case 'schema':
      $ret = y__build_pattern( $module, 'entity',
        array( "*:schema:" => '$1:$2',
               "*:description" => '$1:description',
               "*:properties:*:schema:" => '$1:fields:$2:$3' ), $info );
      break;
    case 'property info alter':
      $ret = y__build_pattern($module, 'entity',
        array( "*:properties:*:info:" => '$1:properties:$2:$3', ),
        $info );
      break;
    default:
      $ret = _y__protocol_default( 'entity', $module, $api, $info );
      break;
  }
  return $ret;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function y_entity_property_info_alter(&$info) {
  $ret = y__protocol_entity(NULL, 'property info alter', $info );
}

/** Function does nothing and can be passed as default to y__plugin so result is guaranteed to be callable */
function _y__donothing() {
  return;
}

/**
 * Plugin functionality
 * if '_y__donothing' passed as default, then it always returns a valid callable function name
 * callback is of form:
 *   callbackname: name_of_function OR
 *   callbackname:
 *     function: name_of_function
 *     uri: file_containing_function_definition
 * @param $info an array of configuration information (eg. all the form information associated with an entity) 
 * @param $type a selector into that array (eg. the bundle name using a form) (use NULL if $info has the callbackname directly)
 * @param $callbackname the callback name (eg. form validation)
 * @param string $default (eg. the name of a default function to be returned if nothing else pans out)
 * @return string the name of a callable function or the default (which may be a callable function name)
 */
function y__plugin( array $info, string $type, string $callbackname, $default='' ): string {
  $callback = ($type === NULL)
    ? $info[$callbackname] ?? $default
    : $info[$type][$callbackname] ?? $default;
  if( $callback ) {
    if( is_array( $callback ) ) {
      if (!empty($callback['uri']) && file_exists($callback['uri'])) {
        require_once $callback['uri'];
      }
      $callbackname = $callback['function'] ?? $default;
    } else {
      $callbackname = $callback;
    }
  } else {
    $callbackname = $default;
  }
  $ret = function_exists($callbackname) ? $callbackname : $default;
  return $ret;
}

/**
 * Implements hook_init() and instantiates all Drupal hooks defined with the "hook" protocol

function _y_init() {
  // Instantiate YAML-defined local hooks
  if ( ($hookfunctiondefs = cache_get(__FUNCTION__)) === FALSE) {
    $hookfunctiondefs = new stdClass();
    $hookfunctiondefs->data = '';

    if ($hookdef = y__protocol_hook(NULL, 'local hooks')) {
      foreach ($hookdef as $hookmodule => $hooks) {
        foreach ($hooks as $hookname => $hookinfo) {
          $hookfunctiondefs->data .= "\nfunction " . $hookmodule . '_' . $hookname . '(){return ' . var_export($hookinfo, TRUE) . ';}';
        }
      }
      cache_set(__FUNCTION__, $hookfunctiondefs->data);
    }
  }
  if (!empty($hookfunctiondefs->data)) {
    try {
      eval($hookfunctiondefs->data);
    }
    catch (ParseError $e) { // got to clear the error-full statement to be able to move forward.
      cache_set( __FUNCTION__, FALSE );
      _drupal_exception_handler( $e );
    }
  }
}
*/

/**
 * Query / display functionality
 */
function y__display_array($table) {
  $args = func_get_args();
  $output = array();
  foreach( $args as $key => $value ) {
    $output[] = array(
      '#title' => $key,
      '#type' => 'textfield',
      '#value' => (string) $value,
    );
  }
  return $output;
}

function y__display_queryresults( $resultset, $format_def ) {
  $output = array();
  $header = array();

  while( $result = $resultset->fetchAssoc() ) {
    if (!$header) {
      $header = $format_def['header'] ?? array_combine(array_keys($result), array_keys($result));
    }
    if( empty($format_def['cols']) ) {
      $output[] = $result;
    } else {
      $row = array();
      foreach( $result as $key => $value ) {

      }
    }

  }
  $form = array(
    'books' => array(
      '#theme' => 'table',
      '#header' => $header,
      '#rows' => $output,
      '#empty' => t('No books available.'),
    )
  );
  return $form;
}

/**
 * transform a token of a particular type into its values
 * @param $token of form
 *   global: globalvarname: globalvarproperty OR
 *           globalvarname
 * @return token value if successful, null if unsuccessful
 */
function _y__token_data( array $token ) {
  $value = reset( $token );
  $method = key($token);
  switch ( $method ) {
    case 'global':
      if (is_array($value)) {
        $varprop = reset($value);
        $varname = key($value);
        global $$varname;
        return $$varname->$varprop;
      }
      else {
        global $$value;
        return $$value;
      }
  }

  return NULL;
}

/**
 * Recursively substitute special patterns in array
 * @param $var
 * @param $substarray
 */
function _y__var_substitute( & $var, $substarray ) {
  if( !is_array($var) ) {
    $var = strtr( $var, $substarray );
  } else {
    foreach( $var as & $value ) {
      _y__var_substitute( $value, $substarray );
    }
  }
}

// Helper function to show a query string
function _y__query_get_string(SelectQueryInterface $query) {
  $string = (string) $query;
  $arguments = $query->arguments();

  if (!empty($arguments) && is_array($arguments)) {
    foreach ($arguments as $placeholder => &$value) {
      if (is_string($value)) {
        $value = "'$value'";
      }
    }

    $string = strtr($string, $arguments);
  }

  return $string;
}

/**
 * Build a query from a query definition array
 * @param $config
 * @return array
 */
function y__query_build( $config ) {
  if( empty($config['base table'])) {
    return array();
  }

  $config += array( 'arguments' => array(), 'build' => array() );
  // Get data values
  foreach( $config['arguments'] as $name => &$value ) {
    $value = _y__token_data( $value );
  }

  // Make the query
  $basetable = reset($config['base table']);
  $basetablealias = $config['base table'][$basetable];
  $query = db_select( $basetable, $basetablealias );
  foreach( $config['build'] as $querycfg ) {
    foreach( $querycfg as $db_op => $args ) {
      _y__var_substitute($args, $config['arguments']);
      if ( in_array($db_op, array( 'addExpression',
        'addField',
        'addJoin',
        'extend',
        'innerJoin',
        'join',
        'leftJoin',
        'rightJoin', ) ) ) {
        $query = call_user_func_array(array($query, $db_op), $args);
      }
      else {
        call_user_func_array( array($query, $db_op), $args);
      }
    }
  }
  return $query;
}

/**
 * Execute a query and display and return results
 * @param $config array of query, arguments, and display
 *   query:
 *     base table:
 *       base_table_name: base_table_name_alias
 *     arguments:
 *       name_of_arg: definition_of_arg (see y__q_datagetter for how to define this
 *     query:
 *     - operation: arguments
 *       differentoperation: arguments
 *     - operation: morearguments...
 *   display:
 *     display callback: name of a function to process the results of the query
 * @return array
 */
function y__db_query_display($config) {

  if( empty($config['query']) || !($query = y__query_build($config['query']))) {
    return array();
  }
  $querystring = _y__query_get_string($query);
  $queryresult = $query->execute();

  // Return results or display output
  if( $displayfunction = y__plugin($config, 'display', 'display callback') ) {
    $ret = call_user_func_array( $displayfunction, array( $queryresult ) );
  } else {
    $ret = $queryresult->fetchAllKeyed();
  }

  return $ret;
}
