<?php

// include field management functionality
require_once 'y.fieldmgt.inc';

/**
 * Implements hook_hook_info().
 */
function y_hook_info() {
  return array( 'y' => array( 'group' => 'y') );
}

/** YAML parsing callbacks *********************************/

/**
 * YAML parse callback general function call
 * @return mixed|null
 */
function y__yaml_callback_call_user_func_array( $value, $tag, $flags ) {
  if( is_array($value) ) {
    $function = array_shift($value);
  } else {
    $function =  $value;
    $value = array();
  }
  return function_exists($function) ? call_user_func_array($function, $value) : NULL;
}

/**
 * YAML parse callback Drupal t() translate
 * @return mixed|null
 */
function y__yaml_callback_t( $value, $tag, $flags ) {
  return t($value);
}

function y__yaml_callback_eval( $value, $tag, $flags ) {
  $ret = array();
  if( !is_array($value) ) {
    $value = array( $value );
  }
  foreach( $value as $key => $evalline ) {
    $evalline = '$ret[$key]=' . $evalline . ';';
    eval($evalline);
  }
  $retval = ((count($ret) == 1) && is_numeric($key)) ? reset($ret) : $ret;
  return $retval;
}

/**
 * YAML parse callback general variable functionality
 * @return mixed|null
 */
function y__yaml_callback_var( $value, $tag, $flags ) {
  static $idx = 0;
  $staticvar = & drupal_static( 'y__static ' . $tag, array() );

  if( !is_array($value) ) {
    $staticvar[$idx] = $value;
  } else {
    foreach( $value as $opcode => $target ) {
      if( is_numeric($opcode) ) {
        $translate = array( '++' => 'inc', 'inc' => 'inc',
          '--' => 'dec', 'dec' => 'dec');
        $opcode = $translate[$target] ?? NULL;
        $target = $opcode ? 0 : 1;
      }
      switch( $opcode ) {
        case 'inc':
        case '+':
          $staticvar[$idx] = $staticvar[$idx] + $target;
          break;
        case 'dec':
        case '-':
          $staticvar[$idx] = $staticvar[$idx] - $target;
          break;
        default:
          $staticvar[$opcode] = $target;
      }
    }
  }
  return $staticvar;
}

/**
 * YAML parse callback Set a plugin value
 * @return mixed|null
 */
function y__yaml_callback_plugin_set( $value, $tag, $flags ) {
  $plugin = & drupal_static('y__yaml_plugin_values', array());
  $plugin = array_merge( $plugin, $value );
  return $value;
}

/**
 * YAML parse callback set info for menu API discoverable plugin
 * @return mixed|null
 * */
function y__yaml_callback_plugin_menucallback( $value, $tag, $flags ) {
  $plugin = & drupal_static('y__yaml_plugin_values', array());
  $includefilearray = array(  'file' => $plugin['file'],
                              'file path' => $plugin['path'] );
  $ret = $value + $includefilearray;
  return $ret;
}

function y__yaml_callback_plugin_callback( $value, $tag, $flags ) {
  $result = array();
  $includefilearray = array();
  $plugin = & drupal_static('y__yaml_plugin_values', array());
  if( !is_array($value)) {
    $result['function'] = $value;
    $includefilearray['uri'] = $plugin['uri']; 
  } else {
    if( !empty($value['plugin']) ) {
      $keys = is_array($value['plugin']) ? $value['plugin'] : array($value['plugin']);
      foreach( $keys as $key ) {
        $includefilearray[$key] = $plugin[$key];  
      }
      unset( $value['plugin'] );
    } 
    $result = $value;
  }
  $result += $includefilearray;
  return $result;
}

/**
 * Set plugin values
 * @param array $initarray
 */
function y__yaml_plugin_values( $initarray=array() ) {
  $plugin = & drupal_static('y__yaml_plugin_values', array());
  $plugin = $initarray;
}

/** Array flattening / unflattening ************************/

/**
 * Flatten an array to one-dimensional with keys imploded with delimiter
 * @param array $array   // array to be flattened
 * @param string $prefix // current prefix for key
 * @param string $delim  // glue delimiter for key
 * @param null $ret      // array to put result in
 * @return array|null    // returns current level of array
 */
function y__array_flatten( array $array, $prefix='', $delim = ':', &$ret=NULL ) {
  if( $ret === NULL ) {
    $ret = array();
  }
  foreach( $array as $key => $value ){
    if( is_array($value) && $value ) {
      y__array_flatten( $value, $prefix . $key . $delim, $delim, $ret );
    } else {
      $ret[ $prefix . $key ] = $value;
    }
  }
  return( $ret );
}

/**
 * Unflatten 1D array into multi-dimensional
 * @param $prefix
 * @param $array / one-dimensional
 * @param string $glue
 */
function y__array_unflatten( array $array, $delim = ':') {
  $ret = array();
  foreach($array as $key => $value) {
    $workret = &$ret;
    $deepkeys = explode( $delim, $key );
    $finalkey = array_shift($deepkeys);
    foreach( $deepkeys as $curkey ) {
      if( !isset($workret[$finalkey] ) ) {
        $workret[$finalkey] = array();
      }
      $workret = &$workret[$finalkey];
      $finalkey = $curkey;
    }
    $workret[$finalkey] = $value;
  }
  return $ret;
}

/** Main YAML retrieval ************************************/

/**
 * Fetch all of the information defined by the owning module according to the protocol
 * @param null $owner
 * @param $protocol
 * @return array of protocol information keyed by module implementing protocol
 *
 * todo: add callback indexing and caching
 */
function y__info( $owner = NULL, $protocol, $format='tree' ) {
  $modulesimplement = &drupal_static(__FUNCTION__ . ':modulesimplement', array());
  // An array keyed by protocol of the modules implementing the protocol
  // Eg. $modulesimplement['hook'] = array( 'bc', 'bcfeeds' )

  $protocolsimplemented = &drupal_static(__FUNCTION__ . ':protocolsimplemented', array());
  // An array keyed by modulename of the protocols implemented by the module
  // Eg. $protocolsimplemented['bc'] = array( 'hook', 'entity', 'bctype' );

  $yinfo = &drupal_static(__FUNCTION__, array());
  // A multi-dim array of the modules implementing protocols keyed by protocol and module
  // Eg. $yinfo[$protocol][$module] = array(... )

  // Initialize self
  if( !isset($modulesimplement[$protocol]) ) {
    // any time a new protocol is requested, something has changed, clear information and reload
    $modulesimplement = array();
    $modulesimplement[$protocol] = array();
    $protocolsimplemented = array();
    $yinfo = array();
    $modules = module_implements( 'y' );
    foreach( $modules as $module ) {
      $protocolsimplemented[$module] = module_invoke($module, 'y');
      foreach( $protocolsimplemented[$module] as $p ){
        if( !isset($modulesimplement[$p])) {
          $modulesimplement[$p] = array();
        }
        $modulesimplement[$p][] = $module;
        if( !isset($yinfo[$p]) ) {
          $yinfo[$p] = array();
        }
      }
    }
  }

  $modules = $owner
    ? array($owner)
    : $modulesimplement[$protocol] ?? array();
  if( !$modules ) {
    return( array() );
  }
  if( $owner && isset($yinfo[$protocol][$owner]) ) {
    return $format ? $yinfo[$protocol][$owner][$format] : $yinfo[$protocol][$owner];
  }

  foreach( $modules as $module ) {
    $callbacks = array(
      '!t' => 'y__yaml_callback_t',
      '!call' => 'y__yaml_callback_call_user_func_array',
      '!var' => 'y__yaml_callback_var',
      '!setplugin' => 'y__yaml_callback_plugin_set',
      '!menucallback' => 'y__yaml_callback_plugin_menucallback',
      '!callback' => 'y__yaml_callback_plugin_callback',
      '!eval' => 'y__yaml_callback_eval',
    );
    // get config path for the module
    if( !isset($yinfo['_config'][$module] ) ) {
      $modulepath = drupal_get_path('module', $module) . '/';
      foreach( array($modulepath => $module . '.yaml', $modulepath . 'config/' => '_config.yaml') as $path => $filename ) {
        if (file_exists($path . $filename) ) {
          $filebase = pathinfo($filename, PATHINFO_FILENAME);
          y__yaml_plugin_values(
            array(
              'path' => $path,
              'type' => '_config',
              'file' => $filebase . 'inc',
              'uri' => $path . $filebase . '.inc',
              'name' => $filebase, // 'bctype'
              'yaml uri' => $path . $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
              'filename' => $filename // 'bctype.yaml'
            ) );
          if((($_config = yaml_parse($path . $filename, 0, $n, $callbacks)) !== FALSE)) {
            if (!isset($_config['path'])) {
              $_config['path'] = $path;
              $_config['filename'] = $filename;
            }
            break;
          }
        }
      }
      $yinfo['_config'][$module] = $_config ?? array('path' => $modulepath . 'config/');
    }
    if (!isset($yinfo[$protocol][$module]) ) {
      $conf = $yinfo['_config'][$module];
      $initarray = isset($yinfo['_config'][$module][$protocol]) ? $yinfo['_config'][$module][$protocol] : array();
      $filename = $conf['path'] . $protocol . '.yaml';
      // todo: find callbacks yaml and callbacks PHP if they will be found
      if( file_exists($filename) ) {
        y__yaml_plugin_values(
          array(
            'path' => $conf['path'],
            'type' => $protocol,
            'file' => $protocol . '.inc',
            'uri' => $conf['path'] . $protocol . '.inc',
            'name' => $protocol, // 'bctype'
            'yaml uri' => $filename, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $protocol . '.yaml' // 'bctype.yaml'
          ) );
        // $protocolinfo = (($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ? $info : $initarray);
        if( ($info = yaml_parse_file($filename, 0, $n, $callbacks)) !== FALSE ) {
          $protocolinfo = $info;
        } else {
          $protocolinfo = $initarray;
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $filename, 'warning');
        }
      } else {
        $protocolinfo = $initarray; 
      }
      $yinfo[$protocol][$module] = $protocolinfo
        ? array( 'tree' => $protocolinfo,
                 'flat' => y__array_flatten($protocolinfo) )
        : array( 'tree' => array(), 'flat' => array() );

      foreach (file_scan_directory($conf['path'] . $protocol, '|.*\.y.?ml|') as $file) {
        y__yaml_plugin_values(
          array(
            'path' => $conf['path'] . $protocol . '/',
            'type' => $protocol,
            'file' => $file->name . '.inc',
            'uri' => $conf['path'] . $protocol . '/' . $file->name . '.inc',
            'name' => $file->name, // 'bctype'
            'yaml uri' => $file->uri, // 'sites/all/modules/enterprise/bc/config/entity/bctype.yaml'
            'filename' => $file->filename // 'bctype.yaml'
         ) );
        if (($info = yaml_parse_file($file->uri, 0, $n, $callbacks)) !== FALSE) {
          $yinfo[$protocol][$module] = array(
            'tree' => array_merge($yinfo[$protocol][$module]['tree'], $info ),
            'flat' => array_merge($yinfo[$protocol][$module]['flat'], y__array_flatten($info) ) );
        } else {
          drupal_set_message('Y ' . __FUNCTION__ . '(' . __LINE__ . ') error parsing ' . $file->uri, 'warning');
        }
      }
    }
  }
  if( $owner ) {
    return isset($yinfo[$protocol][$owner][$format]) ? $yinfo[$protocol][$owner][$format] : array();
  } else {
    $ret = array();
    foreach( $yinfo[$protocol] as $name => $info ) {
      $ret = array_merge( $ret, $format == 'tree' ? array( $name => $info['tree'] ) : $info['flat'] );
    }
    return $ret;
  }
}

/** YAML build functions ***********************************/

/**
 * Build config array from patterns
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $patterns the patterns to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_pattern( $module, $protocol, $patterns, &$ret=NULL ) {
  $yinfo = y__info( $module, $protocol, 'flat' );
  $buildflat = array();
  foreach( $patterns as $pattern => $filter ) {
    if( !is_array($filter) ) { // this is a simple pattern
      $pattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
      $mainpattern = $pattern;
      $mainreplacement = $filter;
    } else { // this is pure regex and all patterns and replacements are regex-perfect
      $mainpattern = array_keys($filter);
      $mainreplacement = array_values($filter);
    }
    $matchingkeys = preg_grep($pattern, array_keys($yinfo));
    $replacementkeys = preg_replace( $mainpattern, $mainreplacement, $matchingkeys );
    foreach( $matchingkeys as $index => $key ) {
      $buildflat[$replacementkeys[$index]] = $yinfo[$key];
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $ret === NULL ) {
    return $buildflat;
  }
  $ret = array_merge($ret, $buildflat);
  return $ret;
}

/**
 * Build branch array to root from pattern
 * @param $module the module defining the configuration
 * @param $protocol the protocol defined
 * @param $pattern the pattern to match
 * @param null & $ret merge results into this array if passed in
 * @return array resulting array
 */
function y__build_branch( $module, $protocol, $pattern, &$ret=NULL ) {
  $branchsearched = array();
  $yinfo = y__info( $module, $protocol, 'flat' );
  $buildflat = array();
  $childpattern = '|^' . strtr($pattern, array('*' => '([^:]*?)')) . '(.*)|';
  $matchingkeys = preg_grep($childpattern, array_keys($yinfo));
  foreach( $matchingkeys as $key ) {
    $buildflat[$key] = $yinfo[$key];
    if( ($colpos = strrpos($key, ':')) !== FALSE ) {
      $key = substr($key, 0, $colpos);
      if( empty($branchsearched[$key]) ) {
        $branchsearched[$key] = TRUE;
        while( ($colpos = strrpos($key, ':')) !== FALSE ) {
          $key = substr($key, 0, $colpos);
          $parentpattern = '|^' . $key . ':([^:]*?)$|';
          $parentkeys = preg_grep($parentpattern, array_keys($yinfo));
          foreach ($parentkeys as $parentkey) {
            if (!isset($buildflat[$parentkey])) {
              $buildflat[$parentkey] = $yinfo[$parentkey];
            }
            else {
              $key = '';
              break;
            }
          }
        }
      }
    }
  }
  $buildflat = y__array_unflatten($buildflat);
  if( $ret === NULL ) {
    return $buildflat;
  }
  $ret = array_merge($ret, $buildflat);
  return $ret;
}

/** Packaged YAML protocol controllers *********************/

/**
 * Main y controller router
 * @param $protocol
 * @param ... more parameters
 * @return array of protocol information supplied by controller
 */
function y__protocol() {
  $args = func_get_args();
  if( count($args) ) {
    $protocol = array_shift( $args );
    if( $protocolcontroller = 'y__protocol_' . $protocol ) {
      if( function_exists($protocolcontroller) ) {
        return call_user_func_array($protocolcontroller, $args);
      }
    }
  }
}

/**
 * Implements protocol 'field'
 * Returns values defined by the y field protocol
 * Defined $api's:
 *   default: is anything in the 'definition' section
 * 
 * Implements:
 *   'local hook' generates local hooks
 */
function y__protocol_field($module, $api, $definingmodule=NULL) {
  static $localhooksgenerated = array();
  $mod = $definingmodule ?? $module;
  switch( $api ) {
    case 'schema':
      $ret = y__build_pattern($mod, 'field', array("*:definition:$api:" => '$2'));
      break;
    default:
      $yinfo = y__info($mod, 'field' );
      $ret = $yinfo[$mod]['definition'][$api];
      break;
  }
  // implement local hooks generation
  if( isset($yinfo[$mod]['local hooks']) && empty($localhooksgenerated[$module]) ) {
    $hookfunctiondefs = '';
    foreach( $yinfo[$mod]['local hooks'] as $hook => $info ) {
      $function = $module . '_' . $hook;
      if( !function_exists($function) ) {
        $hookfunctiondefs .= "\nfunction " . $function . '(){return ' . var_export($info, TRUE) . ';}';
      }
    }
    if( $hookfunctiondefs ) {
      eval( $hookfunctiondefs );
    }
    $localhooksgenerated[$module] = TRUE;
  }

  return $ret;
}

/**
 * Implements protocol 'field'
 * Returns values defined by the y field protocol
 */
function y__protocol_instance($module, $api, $definingmodule=NULL) {
  static $localhooksgenerated = array();
  switch( $api ) {
    default:
      $mod = $definingmodule ?? $module;
      $yinfo = y__info($mod, 'field' );
      $ret = $yinfo[$mod]['definition'][$api];
      break;
  }
  // implement local hooks generation
  if( isset($yinfo[$mod]['local hooks']) && empty($localhooksgenerated[$module]) ) {
    $hookfunctiondefs = '';
    foreach( $yinfo[$mod]['local hooks'] as $hook => $info ) {
      $function = $module . '_' . $hook;
      if( !function_exists($function) ) {
        $hookfunctiondefs .= "\nfunction " . $function . '(){return ' . var_export($info, TRUE) . ';}';
      }
    }
    if( $hookfunctiondefs ) {
      eval( $hookfunctiondefs );
    }
    $localhooksgenerated[$module] = TRUE;
  }

  return $ret;
}

/**
 * Implements protocol 'entity'
 * Returns values defined by the y entity protocol
 */
function y__protocol_entity($module, $api, &$info = NULL) {
  switch( $api ) {
    case 'schema':
      $ret = y__build_pattern( $module, 'entity',
        array( "*:schema:" => '$1:$2',
               "*:description" => '$1:description',
               "*:properties:*:schema:" => '$1:fields:$2:$3' ) );
      break;
    case 'property info alter':
      $ret = y__build_pattern($module, 'entity',
        array( "*:properties:*:info:" => '$1:properties:$2:$3', ),
        $info );
      break;
    default:
      $ret = y__build_pattern( $module, 'entity',
        array( "*:$api:" => '$1:$2' ), $info );
      break;
  }
  return $ret;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function y_entity_property_info_alter(&$info) {
  $ret = y__protocol_entity(NULL, 'property info alter', $info );
}

/**
 * Implements protocol 'hook' 
 * Returns values defined by modules implementing the y hook protocol
 */
function y__protocol_hook( $module, $api=NULL, $hookname=NULL ) {
  if( !$api ) {
    $ret = y__build_pattern( $module, 'hook', array( "*:" => '$1:$2' ) );
  } else {
    if( $module ) {
      $ret = y__build_pattern( $module, 'hook', array( "*:$api:" => '$2' ) );
    } else {
      $ret =  y__build_pattern( $module, 'hook', array( "*:$api:" => '$1:$2' ) );
    }
  }
  return $ret;
}

/** Function does nothing and can be passed as default to y__plugin so result is guaranteed to be callable */
function _y__donothing() {
  return;
}

/**
 * Plugin functionality
 * if '_y__donothing' passed as default, then it always returns a valid callable function name
 * callback is of form:
 *   callbackname: name_of_function OR
 *   callbackname:
 *     function: name_of_function
 *     uri: file_containing_function_definition
 * @param $info an array of configuration information (eg. all the form information associated with an entity) 
 * @param $type a selector into that array (eg. the bundle name using a form) (use NULL if $info has the callbackname directly)
 * @param $callbackname the callback name (eg. form validation)
 * @param string $default (eg. the name of a default function to be returned if nothing else pans out)
 * @return string the name of a callable function or the default (which may be a callable function name)
 */
function y__plugin( array $info, $type, string $callbackname, $default='' ): string {
  $callback = ($type === NULL)
    ? $info[$callbackname] ?? $default
    : $info[$type][$callbackname] ?? $default;
  if( $callback ) {
    if( is_array( $callback ) ) {
      if (!empty($callback['uri']) && file_exists($callback['uri'])) {
        require_once $callback['uri'];
      }
      $callbackname = $callback['function'] ?? $default;
    } else {
      $callbackname = $callback;
    }
  } else {
    $callbackname = $default;
  }
  $ret = function_exists($callbackname) ? $callbackname : $default;
  return $ret;
}

/**
 * Implements hook_init() and instantiates all Drupal hooks defined with the "hook" protocol
 */
function _y_init() {
  // Instantiate YAML-defined local hooks
  if ( ($hookfunctiondefs = cache_get(__FUNCTION__)) === FALSE) {
    $hookfunctiondefs = new stdClass();
    $hookfunctiondefs->data = '';

    if ($hookdef = y__protocol_hook(NULL, 'local hooks')) {
      foreach ($hookdef as $hookmodule => $hooks) {
        foreach ($hooks as $hookname => $hookinfo) {
          $hookfunctiondefs->data .= "\nfunction " . $hookmodule . '_' . $hookname . '(){return ' . var_export($hookinfo, TRUE) . ';}';
        }
      }
      cache_set(__FUNCTION__, $hookfunctiondefs->data);
    }
  }
  if (!empty($hookfunctiondefs->data)) {
    try {
      eval($hookfunctiondefs->data);
    }
    catch (ParseError $e) { // got to clear the error-full statement to be able to move forward.
      cache_set( __FUNCTION__, FALSE );
      _drupal_exception_handler( $e );
    }
  }
}

/**
 * Query / display functionality
 */
function y__displayresults($table) {
  $args = func_get_args();
  $form = array();
  foreach( $args as $key => $value ) {
    $form[] = array(
      '#title' => $key,
      '#type' => 'textfield',
      '#value' => (string) $value,
    );
  }
  return $form;
}

function y__q_datagetter( $datadef ) {
  foreach( $datadef as $method => $value ) {
    switch ( $method ) {
      case 'global':
        if( is_array($value) ) {
          foreach( $value as $varname => $varprop ) {
            global $$varname;
            return $$varname->$varprop;
          }
        } else {
          global $$value;
          return $$value;
        }
    }
  }
  return NULL;
}

/**
 * Recursively substitute special patterns in array
 * @param $var
 * @param $substarray
 */
function _y_var_substitute( & $var, $substarray ) {
  if( !is_array($var) ) {
    $var = strtr( $var, $substarray );
  } else {
    foreach( $var as & $value ) {
      _y_var_substitute( $value, $substarray );
    }
  }
}

// Helper function to show a query string
function y__get_query_string(SelectQueryInterface $query) {
  $string = (string) $query;
  $arguments = $query->arguments();

  if (!empty($arguments) && is_array($arguments)) {
    foreach ($arguments as $placeholder => &$value) {
      if (is_string($value)) {
        $value = "'$value'";
      }
    }

    $string = strtr($string, $arguments);
  }

  return $string;
}

/**
 * Build a query from a query definition array
 * @param $config
 * @return array
 */
function y__view_getquery( $config ) {
  if( empty($config['base table'])) {
    return array();
  }

  $config += array( 'arguments' => array(), 'build' => array() );
  // Get data values
  foreach( $config['arguments'] as $name => &$value ) {
    $value = y__q_datagetter( $value );
  }

  // Make the query
  $basetable = reset($config['base table']);
  $basetablealias = $config['base table'][$basetable];
  $query = db_select( $basetable, $basetablealias );
  foreach( $config['build'] as $querycfg ) {
    foreach( $querycfg as $db_op => $args ) {
      _y_var_substitute($args, $config['arguments']);
      if ( in_array($db_op, array( 'addExpression',
        'addField',
        'addJoin',
        'extend',
        'innerJoin',
        'join',
        'leftJoin',
        'rightJoin', ) ) ) {
        $query = call_user_func_array(array($query, $db_op), $args);
      }
      else {
        call_user_func_array( array($query, $db_op), $args);
      }
    }
  }
  return $query;
}

/**
 * Execute a query and display and return results
 * @param $config array of query, arguments, and display
 *   base table:
 *     base_table_name: base_table_name_alias
 *   arguments:
 *     name_of_arg: definition_of_arg (see y__q_datagetter for how to define this
 *   query:
 *   - operation: arguments
 *     differentoperation: arguments
 *   - operation: morearguments...
 *   display:
 * @return array
 */
function y__view($config) {

  if( empty($config['query']) || !($query = y__view_getquery($config['query']))) {
    return array();
  }
  $querystring = y__get_query_string($query);
  $queryresult = $query->execute();

  // Return results or display output
  if( $displayfunction = y__plugin($config, 'display', 'display callback') ) {
    $ret = call_user_func_array( $displayfunction, array( $queryresult ) );
  } else {
    $ret = $queryresult->fetchAllKeyed();
  }

  return $ret;
}
